/// Generated by the Protocol Buffers 3.5.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "root.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct RootRoot {
    public static let `default` = RootRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}



//Enum type declaration start 

public enum EnumRootType:Int32, GeneratedEnum {
    case enumRootTypeRequest = 1
    case enumRootTypeRespond = 2
    case enumRootTypeError = 3
    case enumRootTypeMessage = 4
    public func toString() -> String {
        switch self {
        case .enumRootTypeRequest: return "enum_root_type_request"
        case .enumRootTypeRespond: return "enum_root_type_respond"
        case .enumRootTypeError: return "enum_root_type_error"
        case .enumRootTypeMessage: return "enum_root_type_message"
        }
    }
    public static func fromString(_ str:String) throws -> EnumRootType {
        switch str {
        case "enum_root_type_request":    return .enumRootTypeRequest
        case "enum_root_type_respond":    return .enumRootTypeRespond
        case "enum_root_type_error":    return .enumRootTypeError
        case "enum_root_type_message":    return .enumRootTypeMessage
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .enumRootTypeRequest: return ".enumRootTypeRequest"
        case .enumRootTypeRespond: return ".enumRootTypeRespond"
        case .enumRootTypeError: return ".enumRootTypeError"
        case .enumRootTypeMessage: return ".enumRootTypeMessage"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:EnumRootType, rhs:EnumRootType) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 



//Enum type declaration start 

public enum EnumRootServer:Int32, GeneratedEnum {
    /// 登陆注册退出
    case enumRootServerLogin = 1
    case enumRootServerPing = 2

    /// 转发消息
    case enumRootServerSentMsg = 3

    /// 群消息
    case enumRootServerGroupMsg = 4

    /// 对所有人关播
    case enumRootServerBroadcast = 5

    /// 推送消息
    case enumRootServerNotification = 6
    public func toString() -> String {
        switch self {
        case .enumRootServerLogin: return "enum_root_server_login"
        case .enumRootServerPing: return "enum_root_server_ping"
        case .enumRootServerSentMsg: return "enum_root_server_sent_msg"
        case .enumRootServerGroupMsg: return "enum_root_server_group_msg"
        case .enumRootServerBroadcast: return "enum_root_server_broadcast"
        case .enumRootServerNotification: return "enum_root_server_notification"
        }
    }
    public static func fromString(_ str:String) throws -> EnumRootServer {
        switch str {
        case "enum_root_server_login":    return .enumRootServerLogin
        case "enum_root_server_ping":    return .enumRootServerPing
        case "enum_root_server_sent_msg":    return .enumRootServerSentMsg
        case "enum_root_server_group_msg":    return .enumRootServerGroupMsg
        case "enum_root_server_broadcast":    return .enumRootServerBroadcast
        case "enum_root_server_notification":    return .enumRootServerNotification
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .enumRootServerLogin: return ".enumRootServerLogin"
        case .enumRootServerPing: return ".enumRootServerPing"
        case .enumRootServerSentMsg: return ".enumRootServerSentMsg"
        case .enumRootServerGroupMsg: return ".enumRootServerGroupMsg"
        case .enumRootServerBroadcast: return ".enumRootServerBroadcast"
        case .enumRootServerNotification: return ".enumRootServerNotification"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:EnumRootServer, rhs:EnumRootServer) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 



//Enum type declaration start 

public enum EnumServerMethod:Int32, GeneratedEnum {
    case login = 1
    case logout = 2
    case signin = 3
    case sentMsg = 10
    case groupMsg = 20
    case broadcast = 30
    case notificationAddFriend = 100
    case notificationReceiveFriend = 102
    case notificationLoginOtherDevice = 103
    case ping = 256
    public func toString() -> String {
        switch self {
        case .login: return "login"
        case .logout: return "logout"
        case .signin: return "signin"
        case .sentMsg: return "sent_msg"
        case .groupMsg: return "group_msg"
        case .broadcast: return "broadcast"
        case .notificationAddFriend: return "notification_addFriend"
        case .notificationReceiveFriend: return "notification_receiveFriend"
        case .notificationLoginOtherDevice: return "notification_login_other_device"
        case .ping: return "ping"
        }
    }
    public static func fromString(_ str:String) throws -> EnumServerMethod {
        switch str {
        case "login":    return .login
        case "logout":    return .logout
        case "signin":    return .signin
        case "sent_msg":    return .sentMsg
        case "group_msg":    return .groupMsg
        case "broadcast":    return .broadcast
        case "notification_addFriend":    return .notificationAddFriend
        case "notification_receiveFriend":    return .notificationReceiveFriend
        case "notification_login_other_device":    return .notificationLoginOtherDevice
        case "ping":    return .ping
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .login: return ".login"
        case .logout: return ".logout"
        case .signin: return ".signin"
        case .sentMsg: return ".sentMsg"
        case .groupMsg: return ".groupMsg"
        case .broadcast: return ".broadcast"
        case .notificationAddFriend: return ".notificationAddFriend"
        case .notificationReceiveFriend: return ".notificationReceiveFriend"
        case .notificationLoginOtherDevice: return ".notificationLoginOtherDevice"
        case .ping: return ".ping"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:EnumServerMethod, rhs:EnumServerMethod) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 

final public class MsgHeader : GeneratedMessage {
    public typealias BuilderType = MsgHeader.Builder

    public static func == (lhs: MsgHeader, rhs: MsgHeader) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
        fieldCheck = fieldCheck && (lhs.hasServer == rhs.hasServer) && (!lhs.hasServer || lhs.server == rhs.server)
        fieldCheck = fieldCheck && (lhs.hasMethod == rhs.hasMethod) && (!lhs.hasMethod || lhs.method == rhs.method)
        fieldCheck = fieldCheck && (lhs.hasUid == rhs.hasUid) && (!lhs.hasUid || lhs.uid == rhs.uid)
        fieldCheck = fieldCheck && (lhs.hasAutoToken == rhs.hasAutoToken) && (!lhs.hasAutoToken || lhs.autoToken == rhs.autoToken)
        fieldCheck = fieldCheck && (lhs.hasSeq == rhs.hasSeq) && (!lhs.hasSeq || lhs.seq == rhs.seq)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var type:EnumRootType = EnumRootType.enumRootTypeRequest
    public fileprivate(set) var hasType:Bool = false
    public fileprivate(set) var server:EnumRootServer = EnumRootServer.enumRootServerLogin
    public fileprivate(set) var hasServer:Bool = false
    public fileprivate(set) var method:EnumServerMethod = EnumServerMethod.login
    public fileprivate(set) var hasMethod:Bool = false
    public fileprivate(set) var uid:UInt32! = nil
    public fileprivate(set) var hasUid:Bool = false

    public fileprivate(set) var autoToken:Int32! = nil
    public fileprivate(set) var hasAutoToken:Bool = false

    public fileprivate(set) var seq:Int32! = nil
    public fileprivate(set) var hasSeq:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasType {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(MsgHeader.self): field \"type\" mark required")
        }
        if !hasServer {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(MsgHeader.self): field \"server\" mark required")
        }
        if !hasMethod {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(MsgHeader.self): field \"method\" mark required")
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasType {
            try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
        }
        if hasServer {
            try codedOutputStream.writeEnum(fieldNumber: 2, value:server.rawValue)
        }
        if hasMethod {
            try codedOutputStream.writeEnum(fieldNumber: 3, value:method.rawValue)
        }
        if hasUid {
            try codedOutputStream.writeUInt32(fieldNumber: 4, value:uid)
        }
        if hasAutoToken {
            try codedOutputStream.writeInt32(fieldNumber: 5, value:autoToken)
        }
        if hasSeq {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:seq)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasType) {
            serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
        }
        if (hasServer) {
            serialize_size += server.rawValue.computeEnumSize(fieldNumber: 2)
        }
        if (hasMethod) {
            serialize_size += method.rawValue.computeEnumSize(fieldNumber: 3)
        }
        if hasUid {
            serialize_size += uid.computeUInt32Size(fieldNumber: 4)
        }
        if hasAutoToken {
            serialize_size += autoToken.computeInt32Size(fieldNumber: 5)
        }
        if hasSeq {
            serialize_size += seq.computeInt32Size(fieldNumber: 6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> MsgHeader.Builder {
        return MsgHeader.classBuilder() as! MsgHeader.Builder
    }
    public func getBuilder() -> MsgHeader.Builder {
        return classBuilder() as! MsgHeader.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MsgHeader.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MsgHeader.Builder()
    }
    public func toBuilder() throws -> MsgHeader.Builder {
        return try MsgHeader.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:MsgHeader) throws -> MsgHeader.Builder {
        return try MsgHeader.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasType {
            jsonMap["type"] = type.toString()
        }
        if hasServer {
            jsonMap["server"] = server.toString()
        }
        if hasMethod {
            jsonMap["method"] = method.toString()
        }
        if hasUid {
            jsonMap["uid"] = UInt(uid)
        }
        if hasAutoToken {
            jsonMap["autoToken"] = Int(autoToken)
        }
        if hasSeq {
            jsonMap["seq"] = Int(seq)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> MsgHeader {
        return try MsgHeader.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> MsgHeader {
        return try MsgHeader.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if (hasType) {
            output += "\(indent) type: \(type.description)\n"
        }
        if (hasServer) {
            output += "\(indent) server: \(server.description)\n"
        }
        if (hasMethod) {
            output += "\(indent) method: \(method.description)\n"
        }
        if hasUid {
            output += "\(indent) uid: \(uid) \n"
        }
        if hasAutoToken {
            output += "\(indent) autoToken: \(autoToken) \n"
        }
        if hasSeq {
            output += "\(indent) seq: \(seq) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasType {
                 hashCode = (hashCode &* 31) &+ type.hashValue
            }
            if hasServer {
                 hashCode = (hashCode &* 31) &+ server.hashValue
            }
            if hasMethod {
                 hashCode = (hashCode &* 31) &+ method.hashValue
            }
            if hasUid {
                hashCode = (hashCode &* 31) &+ uid.hashValue
            }
            if hasAutoToken {
                hashCode = (hashCode &* 31) &+ autoToken.hashValue
            }
            if hasSeq {
                hashCode = (hashCode &* 31) &+ seq.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "MsgHeader"
    }
    override public func className() -> String {
        return "MsgHeader"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:MsgHeader = MsgHeader()
        public func getMessage() -> MsgHeader {
            return builderResult
        }

        required override public init () {
            super.init()
        }
            public var type:EnumRootType {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool{
                get {
                    return builderResult.hasType
                }
            }
        @discardableResult
            public func setType(_ value:EnumRootType) -> MsgHeader.Builder {
              self.type = value
              return self
            }
        @discardableResult
            public func clearType() -> MsgHeader.Builder {
               builderResult.hasType = false
               builderResult.type = .enumRootTypeRequest
               return self
            }
            public var server:EnumRootServer {
                get {
                    return builderResult.server
                }
                set (value) {
                    builderResult.hasServer = true
                    builderResult.server = value
                }
            }
            public var hasServer:Bool{
                get {
                    return builderResult.hasServer
                }
            }
        @discardableResult
            public func setServer(_ value:EnumRootServer) -> MsgHeader.Builder {
              self.server = value
              return self
            }
        @discardableResult
            public func clearServer() -> MsgHeader.Builder {
               builderResult.hasServer = false
               builderResult.server = .enumRootServerLogin
               return self
            }
            public var method:EnumServerMethod {
                get {
                    return builderResult.method
                }
                set (value) {
                    builderResult.hasMethod = true
                    builderResult.method = value
                }
            }
            public var hasMethod:Bool{
                get {
                    return builderResult.hasMethod
                }
            }
        @discardableResult
            public func setMethod(_ value:EnumServerMethod) -> MsgHeader.Builder {
              self.method = value
              return self
            }
        @discardableResult
            public func clearMethod() -> MsgHeader.Builder {
               builderResult.hasMethod = false
               builderResult.method = .login
               return self
            }
        public var uid:UInt32 {
            get {
                return builderResult.uid
            }
            set (value) {
                builderResult.hasUid = true
                builderResult.uid = value
            }
        }
        public var hasUid:Bool {
            get {
                return builderResult.hasUid
            }
        }
        @discardableResult
        public func setUid(_ value:UInt32) -> MsgHeader.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> MsgHeader.Builder{
            builderResult.hasUid = false
            builderResult.uid = nil
            return self
        }
        public var autoToken:Int32 {
            get {
                return builderResult.autoToken
            }
            set (value) {
                builderResult.hasAutoToken = true
                builderResult.autoToken = value
            }
        }
        public var hasAutoToken:Bool {
            get {
                return builderResult.hasAutoToken
            }
        }
        @discardableResult
        public func setAutoToken(_ value:Int32) -> MsgHeader.Builder {
            self.autoToken = value
            return self
        }
        @discardableResult
        public func clearAutoToken() -> MsgHeader.Builder{
            builderResult.hasAutoToken = false
            builderResult.autoToken = nil
            return self
        }
        public var seq:Int32 {
            get {
                return builderResult.seq
            }
            set (value) {
                builderResult.hasSeq = true
                builderResult.seq = value
            }
        }
        public var hasSeq:Bool {
            get {
                return builderResult.hasSeq
            }
        }
        @discardableResult
        public func setSeq(_ value:Int32) -> MsgHeader.Builder {
            self.seq = value
            return self
        }
        @discardableResult
        public func clearSeq() -> MsgHeader.Builder{
            builderResult.hasSeq = false
            builderResult.seq = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> MsgHeader.Builder {
            builderResult = MsgHeader()
            return self
        }
        override public func clone() throws -> MsgHeader.Builder {
            return try MsgHeader.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> MsgHeader {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> MsgHeader {
            let returnMe:MsgHeader = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:MsgHeader) throws -> MsgHeader.Builder {
            if other == MsgHeader() {
                return self
            }
            if other.hasType {
                type = other.type
            }
            if other.hasServer {
                server = other.server
            }
            if other.hasMethod {
                method = other.method
            }
            if other.hasUid {
                uid = other.uid
            }
            if other.hasAutoToken {
                autoToken = other.autoToken
            }
            if other.hasSeq {
                seq = other.seq
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> MsgHeader.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MsgHeader.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    let valueInttype = try codedInputStream.readEnum()
                    if let enumstype = EnumRootType(rawValue:valueInttype){
                        type = enumstype
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                    }

                case 16:
                    let valueIntserver = try codedInputStream.readEnum()
                    if let enumsserver = EnumRootServer(rawValue:valueIntserver){
                        server = enumsserver
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntserver))
                    }

                case 24:
                    let valueIntmethod = try codedInputStream.readEnum()
                    if let enumsmethod = EnumServerMethod(rawValue:valueIntmethod){
                        method = enumsmethod
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntmethod))
                    }

                case 32:
                    uid = try codedInputStream.readUInt32()

                case 40:
                    autoToken = try codedInputStream.readInt32()

                case 48:
                    seq = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> MsgHeader.Builder {
            let resultDecodedBuilder = MsgHeader.Builder()
            if let jsonValueType = jsonMap["type"] as? String {
                resultDecodedBuilder.type = try EnumRootType.fromString(jsonValueType)
            }
            if let jsonValueServer = jsonMap["server"] as? String {
                resultDecodedBuilder.server = try EnumRootServer.fromString(jsonValueServer)
            }
            if let jsonValueMethod = jsonMap["method"] as? String {
                resultDecodedBuilder.method = try EnumServerMethod.fromString(jsonValueMethod)
            }
            if let jsonValueUid = jsonMap["uid"] as? UInt {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)
            } else if let jsonValueUid = jsonMap["uid"] as? String {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)!
            }
            if let jsonValueAutoToken = jsonMap["autoToken"] as? Int {
                resultDecodedBuilder.autoToken = Int32(jsonValueAutoToken)
            } else if let jsonValueAutoToken = jsonMap["autoToken"] as? String {
                resultDecodedBuilder.autoToken = Int32(jsonValueAutoToken)!
            }
            if let jsonValueSeq = jsonMap["seq"] as? Int {
                resultDecodedBuilder.seq = Int32(jsonValueSeq)
            } else if let jsonValueSeq = jsonMap["seq"] as? String {
                resultDecodedBuilder.seq = Int32(jsonValueSeq)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> MsgHeader.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try MsgHeader.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ExtKeyInfo : GeneratedMessage {
    public typealias BuilderType = ExtKeyInfo.Builder

    public static func == (lhs: ExtKeyInfo, rhs: ExtKeyInfo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:String! = nil
    public fileprivate(set) var hasKey:Bool = false

    public fileprivate(set) var value:String! = nil
    public fileprivate(set) var hasValue:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasKey {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(ExtKeyInfo.self): field \"key\" mark required")
        }
        if !hasValue {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(ExtKeyInfo.self): field \"value\" mark required")
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
        }
        if hasValue {
            try codedOutputStream.writeString(fieldNumber: 2, value:value)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
        }
        if hasValue {
            serialize_size += value.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ExtKeyInfo.Builder {
        return ExtKeyInfo.classBuilder() as! ExtKeyInfo.Builder
    }
    public func getBuilder() -> ExtKeyInfo.Builder {
        return classBuilder() as! ExtKeyInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ExtKeyInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ExtKeyInfo.Builder()
    }
    public func toBuilder() throws -> ExtKeyInfo.Builder {
        return try ExtKeyInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ExtKeyInfo) throws -> ExtKeyInfo.Builder {
        return try ExtKeyInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key
        }
        if hasValue {
            jsonMap["value"] = value
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        if hasValue {
            output += "\(indent) value: \(value) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            if hasValue {
                hashCode = (hashCode &* 31) &+ value.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ExtKeyInfo"
    }
    override public func className() -> String {
        return "ExtKeyInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ExtKeyInfo = ExtKeyInfo()
        public func getMessage() -> ExtKeyInfo {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:String {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:String) -> ExtKeyInfo.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> ExtKeyInfo.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        public var value:String {
            get {
                return builderResult.value
            }
            set (value) {
                builderResult.hasValue = true
                builderResult.value = value
            }
        }
        public var hasValue:Bool {
            get {
                return builderResult.hasValue
            }
        }
        @discardableResult
        public func setValue(_ value:String) -> ExtKeyInfo.Builder {
            self.value = value
            return self
        }
        @discardableResult
        public func clearValue() -> ExtKeyInfo.Builder{
            builderResult.hasValue = false
            builderResult.value = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ExtKeyInfo.Builder {
            builderResult = ExtKeyInfo()
            return self
        }
        override public func clone() throws -> ExtKeyInfo.Builder {
            return try ExtKeyInfo.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ExtKeyInfo {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ExtKeyInfo {
            let returnMe:ExtKeyInfo = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ExtKeyInfo) throws -> ExtKeyInfo.Builder {
            if other == ExtKeyInfo() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            if other.hasValue {
                value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ExtKeyInfo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ExtKeyInfo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readString()

                case 18:
                    value = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ExtKeyInfo.Builder {
            let resultDecodedBuilder = ExtKeyInfo.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? String {
                resultDecodedBuilder.value = jsonValueValue
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ExtKeyInfo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ExtKeyInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Root : GeneratedMessage {
    public typealias BuilderType = Root.Builder

    public static func == (lhs: Root, rhs: Root) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = fieldCheck && (lhs.hasExt == rhs.hasExt) && (!lhs.hasExt || lhs.ext == rhs.ext)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var header:MsgHeader!
    public fileprivate(set) var hasHeader:Bool = false
    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    public fileprivate(set) var ext:ExtKeyInfo!
    public fileprivate(set) var hasExt:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasHeader {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(Root.self): field \"header\" mark required")
        }
        try header.isInitialized()
        if hasExt {
            try ext.isInitialized()
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasHeader {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:header)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 2, value:body)
        }
        if hasExt {
            try codedOutputStream.writeMessage(fieldNumber: 3, value:ext)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasHeader {
            if let varSizeheader = header?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeheader
            }
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 2)
        }
        if hasExt {
            if let varSizeext = ext?.computeMessageSize(fieldNumber: 3) {
                serialize_size += varSizeext
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Root.Builder {
        return Root.classBuilder() as! Root.Builder
    }
    public func getBuilder() -> Root.Builder {
        return classBuilder() as! Root.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Root.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Root.Builder()
    }
    public func toBuilder() throws -> Root.Builder {
        return try Root.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Root) throws -> Root.Builder {
        return try Root.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasHeader {
            jsonMap["header"] = try header.encode()
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        if hasExt {
            jsonMap["ext"] = try ext.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Root {
        return try Root.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Root {
        return try Root.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasHeader {
            output += "\(indent) header {\n"
            if let outDescHeader = header {
                output += try outDescHeader.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        if hasExt {
            output += "\(indent) ext {\n"
            if let outDescExt = ext {
                output += try outDescExt.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasHeader {
                if let hashValueheader = header?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueheader
                }
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            if hasExt {
                if let hashValueext = ext?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueext
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Root"
    }
    override public func className() -> String {
        return "Root"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Root = Root()
        public func getMessage() -> Root {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var header:MsgHeader! {
            get {
                if headerBuilder_ != nil {
                    builderResult.header = headerBuilder_.getMessage()
                }
                return builderResult.header
            }
            set (value) {
                builderResult.hasHeader = value != nil
                builderResult.header = value
            }
        }
        public var hasHeader:Bool {
            get {
                return builderResult.hasHeader
            }
        }
        fileprivate var headerBuilder_:MsgHeader.Builder! {
            didSet {
                builderResult.hasHeader = true
            }
        }
        public func getHeaderBuilder() -> MsgHeader.Builder {
            if headerBuilder_ == nil {
                headerBuilder_ = MsgHeader.Builder()
                builderResult.header = headerBuilder_.getMessage()
                if header != nil {
                    try! headerBuilder_.mergeFrom(other: header)
                }
            }
            return headerBuilder_
        }
        @discardableResult
        public func setHeader(_ value:MsgHeader!) -> Root.Builder {
            self.header = value
            return self
        }
        @discardableResult
        public func mergeHeader(value:MsgHeader) throws -> Root.Builder {
            if builderResult.hasHeader {
                builderResult.header = try MsgHeader.builderWithPrototype(prototype:builderResult.header).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.header = value
            }
            builderResult.hasHeader = true
            return self
        }
        @discardableResult
        public func clearHeader() -> Root.Builder {
            headerBuilder_ = nil
            builderResult.hasHeader = false
            builderResult.header = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> Root.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> Root.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        public var ext:ExtKeyInfo! {
            get {
                if extBuilder_ != nil {
                    builderResult.ext = extBuilder_.getMessage()
                }
                return builderResult.ext
            }
            set (value) {
                builderResult.hasExt = value != nil
                builderResult.ext = value
            }
        }
        public var hasExt:Bool {
            get {
                return builderResult.hasExt
            }
        }
        fileprivate var extBuilder_:ExtKeyInfo.Builder! {
            didSet {
                builderResult.hasExt = true
            }
        }
        public func getExtBuilder() -> ExtKeyInfo.Builder {
            if extBuilder_ == nil {
                extBuilder_ = ExtKeyInfo.Builder()
                builderResult.ext = extBuilder_.getMessage()
                if ext != nil {
                    try! extBuilder_.mergeFrom(other: ext)
                }
            }
            return extBuilder_
        }
        @discardableResult
        public func setExt(_ value:ExtKeyInfo!) -> Root.Builder {
            self.ext = value
            return self
        }
        @discardableResult
        public func mergeExt(value:ExtKeyInfo) throws -> Root.Builder {
            if builderResult.hasExt {
                builderResult.ext = try ExtKeyInfo.builderWithPrototype(prototype:builderResult.ext).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.ext = value
            }
            builderResult.hasExt = true
            return self
        }
        @discardableResult
        public func clearExt() -> Root.Builder {
            extBuilder_ = nil
            builderResult.hasExt = false
            builderResult.ext = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Root.Builder {
            builderResult = Root()
            return self
        }
        override public func clone() throws -> Root.Builder {
            return try Root.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Root {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Root {
            let returnMe:Root = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Root) throws -> Root.Builder {
            if other == Root() {
                return self
            }
            if (other.hasHeader) {
                try mergeHeader(value: other.header)
            }
            if other.hasBody {
                body = other.body
            }
            if (other.hasExt) {
                try mergeExt(value: other.ext)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Root.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Root.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:MsgHeader.Builder = MsgHeader.Builder()
                    if hasHeader {
                        try subBuilder.mergeFrom(other: header)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    header = subBuilder.buildPartial()

                case 18:
                    body = try codedInputStream.readData()

                case 26:
                    let subBuilder:ExtKeyInfo.Builder = ExtKeyInfo.Builder()
                    if hasExt {
                        try subBuilder.mergeFrom(other: ext)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    ext = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Root.Builder {
            let resultDecodedBuilder = Root.Builder()
            if let jsonValueHeader = jsonMap["header"] as? Dictionary<String,Any> {
                resultDecodedBuilder.header = try MsgHeader.Builder.decodeToBuilder(jsonMap:jsonValueHeader).build()

            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            if let jsonValueExt = jsonMap["ext"] as? Dictionary<String,Any> {
                resultDecodedBuilder.ext = try ExtKeyInfo.Builder.decodeToBuilder(jsonMap:jsonValueExt).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Root.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Root.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class UserInfo : GeneratedMessage {
    public typealias BuilderType = UserInfo.Builder

    public static func == (lhs: UserInfo, rhs: UserInfo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUid == rhs.hasUid) && (!lhs.hasUid || lhs.uid == rhs.uid)
        fieldCheck = fieldCheck && (lhs.hasNickName == rhs.hasNickName) && (!lhs.hasNickName || lhs.nickName == rhs.nickName)
        fieldCheck = fieldCheck && (lhs.hasAvartaUrl == rhs.hasAvartaUrl) && (!lhs.hasAvartaUrl || lhs.avartaUrl == rhs.avartaUrl)
        fieldCheck = fieldCheck && (lhs.hasIsOnline == rhs.hasIsOnline) && (!lhs.hasIsOnline || lhs.isOnline == rhs.isOnline)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var uid:Int32! = nil
    public fileprivate(set) var hasUid:Bool = false

    public fileprivate(set) var nickName:String! = nil
    public fileprivate(set) var hasNickName:Bool = false

    public fileprivate(set) var avartaUrl:String! = nil
    public fileprivate(set) var hasAvartaUrl:Bool = false

    public fileprivate(set) var isOnline:Int32! = nil
    public fileprivate(set) var hasIsOnline:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasUid {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserInfo.self): field \"uid\" mark required")
        }
        if !hasNickName {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserInfo.self): field \"nickName\" mark required")
        }
        if !hasAvartaUrl {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserInfo.self): field \"avartaUrl\" mark required")
        }
        if !hasIsOnline {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserInfo.self): field \"isOnline\" mark required")
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUid {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:uid)
        }
        if hasNickName {
            try codedOutputStream.writeString(fieldNumber: 2, value:nickName)
        }
        if hasAvartaUrl {
            try codedOutputStream.writeString(fieldNumber: 3, value:avartaUrl)
        }
        if hasIsOnline {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:isOnline)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUid {
            serialize_size += uid.computeInt32Size(fieldNumber: 1)
        }
        if hasNickName {
            serialize_size += nickName.computeStringSize(fieldNumber: 2)
        }
        if hasAvartaUrl {
            serialize_size += avartaUrl.computeStringSize(fieldNumber: 3)
        }
        if hasIsOnline {
            serialize_size += isOnline.computeInt32Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UserInfo.Builder {
        return UserInfo.classBuilder() as! UserInfo.Builder
    }
    public func getBuilder() -> UserInfo.Builder {
        return classBuilder() as! UserInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfo.Builder()
    }
    public func toBuilder() throws -> UserInfo.Builder {
        return try UserInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UserInfo) throws -> UserInfo.Builder {
        return try UserInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUid {
            jsonMap["uid"] = Int(uid)
        }
        if hasNickName {
            jsonMap["nickName"] = nickName
        }
        if hasAvartaUrl {
            jsonMap["avartaUrl"] = avartaUrl
        }
        if hasIsOnline {
            jsonMap["isOnline"] = Int(isOnline)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserInfo {
        return try UserInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> UserInfo {
        return try UserInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUid {
            output += "\(indent) uid: \(uid) \n"
        }
        if hasNickName {
            output += "\(indent) nickName: \(nickName) \n"
        }
        if hasAvartaUrl {
            output += "\(indent) avartaUrl: \(avartaUrl) \n"
        }
        if hasIsOnline {
            output += "\(indent) isOnline: \(isOnline) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUid {
                hashCode = (hashCode &* 31) &+ uid.hashValue
            }
            if hasNickName {
                hashCode = (hashCode &* 31) &+ nickName.hashValue
            }
            if hasAvartaUrl {
                hashCode = (hashCode &* 31) &+ avartaUrl.hashValue
            }
            if hasIsOnline {
                hashCode = (hashCode &* 31) &+ isOnline.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UserInfo"
    }
    override public func className() -> String {
        return "UserInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UserInfo = UserInfo()
        public func getMessage() -> UserInfo {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var uid:Int32 {
            get {
                return builderResult.uid
            }
            set (value) {
                builderResult.hasUid = true
                builderResult.uid = value
            }
        }
        public var hasUid:Bool {
            get {
                return builderResult.hasUid
            }
        }
        @discardableResult
        public func setUid(_ value:Int32) -> UserInfo.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> UserInfo.Builder{
            builderResult.hasUid = false
            builderResult.uid = nil
            return self
        }
        public var nickName:String {
            get {
                return builderResult.nickName
            }
            set (value) {
                builderResult.hasNickName = true
                builderResult.nickName = value
            }
        }
        public var hasNickName:Bool {
            get {
                return builderResult.hasNickName
            }
        }
        @discardableResult
        public func setNickName(_ value:String) -> UserInfo.Builder {
            self.nickName = value
            return self
        }
        @discardableResult
        public func clearNickName() -> UserInfo.Builder{
            builderResult.hasNickName = false
            builderResult.nickName = nil
            return self
        }
        public var avartaUrl:String {
            get {
                return builderResult.avartaUrl
            }
            set (value) {
                builderResult.hasAvartaUrl = true
                builderResult.avartaUrl = value
            }
        }
        public var hasAvartaUrl:Bool {
            get {
                return builderResult.hasAvartaUrl
            }
        }
        @discardableResult
        public func setAvartaUrl(_ value:String) -> UserInfo.Builder {
            self.avartaUrl = value
            return self
        }
        @discardableResult
        public func clearAvartaUrl() -> UserInfo.Builder{
            builderResult.hasAvartaUrl = false
            builderResult.avartaUrl = nil
            return self
        }
        public var isOnline:Int32 {
            get {
                return builderResult.isOnline
            }
            set (value) {
                builderResult.hasIsOnline = true
                builderResult.isOnline = value
            }
        }
        public var hasIsOnline:Bool {
            get {
                return builderResult.hasIsOnline
            }
        }
        @discardableResult
        public func setIsOnline(_ value:Int32) -> UserInfo.Builder {
            self.isOnline = value
            return self
        }
        @discardableResult
        public func clearIsOnline() -> UserInfo.Builder{
            builderResult.hasIsOnline = false
            builderResult.isOnline = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UserInfo.Builder {
            builderResult = UserInfo()
            return self
        }
        override public func clone() throws -> UserInfo.Builder {
            return try UserInfo.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserInfo {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UserInfo {
            let returnMe:UserInfo = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UserInfo) throws -> UserInfo.Builder {
            if other == UserInfo() {
                return self
            }
            if other.hasUid {
                uid = other.uid
            }
            if other.hasNickName {
                nickName = other.nickName
            }
            if other.hasAvartaUrl {
                avartaUrl = other.avartaUrl
            }
            if other.hasIsOnline {
                isOnline = other.isOnline
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserInfo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    uid = try codedInputStream.readInt32()

                case 18:
                    nickName = try codedInputStream.readString()

                case 26:
                    avartaUrl = try codedInputStream.readString()

                case 32:
                    isOnline = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserInfo.Builder {
            let resultDecodedBuilder = UserInfo.Builder()
            if let jsonValueUid = jsonMap["uid"] as? Int {
                resultDecodedBuilder.uid = Int32(jsonValueUid)
            } else if let jsonValueUid = jsonMap["uid"] as? String {
                resultDecodedBuilder.uid = Int32(jsonValueUid)!
            }
            if let jsonValueNickName = jsonMap["nickName"] as? String {
                resultDecodedBuilder.nickName = jsonValueNickName
            }
            if let jsonValueAvartaUrl = jsonMap["avartaUrl"] as? String {
                resultDecodedBuilder.avartaUrl = jsonValueAvartaUrl
            }
            if let jsonValueIsOnline = jsonMap["isOnline"] as? Int {
                resultDecodedBuilder.isOnline = Int32(jsonValueIsOnline)
            } else if let jsonValueIsOnline = jsonMap["isOnline"] as? String {
                resultDecodedBuilder.isOnline = Int32(jsonValueIsOnline)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UserInfo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UserInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension MsgHeader: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<MsgHeader> {
        var mergedArray = Array<MsgHeader>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> MsgHeader? {
        return try MsgHeader.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(data: data, extensionRegistry:RootRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MsgHeader {
        return try MsgHeader.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "server": return self.server
        case "method": return self.method
        case "uid": return self.uid
        case "autoToken": return self.autoToken
        case "seq": return self.seq
        default: return nil
        }
    }
}
extension MsgHeader.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = MsgHeader
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "server": return self.server
            case "method": return self.method
            case "uid": return self.uid
            case "autoToken": return self.autoToken
            case "seq": return self.seq
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? EnumRootType else {
                    return
                }
                self.type = newSubscriptValue
            case "server":
                guard let newSubscriptValue = newSubscriptValue as? EnumRootServer else {
                    return
                }
                self.server = newSubscriptValue
            case "method":
                guard let newSubscriptValue = newSubscriptValue as? EnumServerMethod else {
                    return
                }
                self.method = newSubscriptValue
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.uid = newSubscriptValue
            case "autoToken":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.autoToken = newSubscriptValue
            case "seq":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.seq = newSubscriptValue
            default: return
            }
        }
    }
}
extension ExtKeyInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ExtKeyInfo> {
        var mergedArray = Array<ExtKeyInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ExtKeyInfo? {
        return try ExtKeyInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(data: data, extensionRegistry:RootRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ExtKeyInfo {
        return try ExtKeyInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension ExtKeyInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ExtKeyInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Root: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Root> {
        var mergedArray = Array<Root>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Root? {
        return try Root.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Root {
        return try Root.Builder().mergeFrom(data: data, extensionRegistry:RootRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Root {
        return try Root.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Root {
        return try Root.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Root {
        return try Root.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Root {
        return try Root.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Root {
        return try Root.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "header": return self.header
        case "body": return self.body
        case "ext": return self.ext
        default: return nil
        }
    }
}
extension Root.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Root
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "header": return self.header
            case "body": return self.body
            case "ext": return self.ext
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "header":
                guard let newSubscriptValue = newSubscriptValue as? MsgHeader else {
                    return
                }
                self.header = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            case "ext":
                guard let newSubscriptValue = newSubscriptValue as? ExtKeyInfo else {
                    return
                }
                self.ext = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserInfo> {
        var mergedArray = Array<UserInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserInfo? {
        return try UserInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(data: data, extensionRegistry:RootRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfo {
        return try UserInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uid": return self.uid
        case "nickName": return self.nickName
        case "avartaUrl": return self.avartaUrl
        case "isOnline": return self.isOnline
        default: return nil
        }
    }
}
extension UserInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uid": return self.uid
            case "nickName": return self.nickName
            case "avartaUrl": return self.avartaUrl
            case "isOnline": return self.isOnline
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.uid = newSubscriptValue
            case "nickName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nickName = newSubscriptValue
            case "avartaUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.avartaUrl = newSubscriptValue
            case "isOnline":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.isOnline = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
