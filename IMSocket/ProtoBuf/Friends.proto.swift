/// Generated by the Protocol Buffers 3.5.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "friends.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct FriendsRoot {
    public static let `default` = FriendsRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
        BaseRoot.default.registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class AddFriendReq : GeneratedMessage {
    public typealias BuilderType = AddFriendReq.Builder

    public static func == (lhs: AddFriendReq, rhs: AddFriendReq) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasTargetId == rhs.hasTargetId) && (!lhs.hasTargetId || lhs.targetId == rhs.targetId)
        fieldCheck = fieldCheck && (lhs.hasExtMsg == rhs.hasExtMsg) && (!lhs.hasExtMsg || lhs.extMsg == rhs.extMsg)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var targetId:String! = nil
    public fileprivate(set) var hasTargetId:Bool = false

    public fileprivate(set) var extMsg:String! = nil
    public fileprivate(set) var hasExtMsg:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasTargetId {
            try codedOutputStream.writeString(fieldNumber: 1, value:targetId)
        }
        if hasExtMsg {
            try codedOutputStream.writeString(fieldNumber: 2, value:extMsg)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasTargetId {
            serialize_size += targetId.computeStringSize(fieldNumber: 1)
        }
        if hasExtMsg {
            serialize_size += extMsg.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AddFriendReq.Builder {
        return AddFriendReq.classBuilder() as! AddFriendReq.Builder
    }
    public func getBuilder() -> AddFriendReq.Builder {
        return classBuilder() as! AddFriendReq.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AddFriendReq.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AddFriendReq.Builder()
    }
    public func toBuilder() throws -> AddFriendReq.Builder {
        return try AddFriendReq.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AddFriendReq) throws -> AddFriendReq.Builder {
        return try AddFriendReq.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasTargetId {
            jsonMap["targetId"] = targetId
        }
        if hasExtMsg {
            jsonMap["extMsg"] = extMsg
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AddFriendReq {
        return try AddFriendReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AddFriendReq {
        return try AddFriendReq.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasTargetId {
            output += "\(indent) targetId: \(targetId) \n"
        }
        if hasExtMsg {
            output += "\(indent) extMsg: \(extMsg) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTargetId {
                hashCode = (hashCode &* 31) &+ targetId.hashValue
            }
            if hasExtMsg {
                hashCode = (hashCode &* 31) &+ extMsg.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AddFriendReq"
    }
    override public func className() -> String {
        return "AddFriendReq"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AddFriendReq = AddFriendReq()
        public func getMessage() -> AddFriendReq {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var targetId:String {
            get {
                return builderResult.targetId
            }
            set (value) {
                builderResult.hasTargetId = true
                builderResult.targetId = value
            }
        }
        public var hasTargetId:Bool {
            get {
                return builderResult.hasTargetId
            }
        }
        @discardableResult
        public func setTargetId(_ value:String) -> AddFriendReq.Builder {
            self.targetId = value
            return self
        }
        @discardableResult
        public func clearTargetId() -> AddFriendReq.Builder{
            builderResult.hasTargetId = false
            builderResult.targetId = nil
            return self
        }
        public var extMsg:String {
            get {
                return builderResult.extMsg
            }
            set (value) {
                builderResult.hasExtMsg = true
                builderResult.extMsg = value
            }
        }
        public var hasExtMsg:Bool {
            get {
                return builderResult.hasExtMsg
            }
        }
        @discardableResult
        public func setExtMsg(_ value:String) -> AddFriendReq.Builder {
            self.extMsg = value
            return self
        }
        @discardableResult
        public func clearExtMsg() -> AddFriendReq.Builder{
            builderResult.hasExtMsg = false
            builderResult.extMsg = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AddFriendReq.Builder {
            builderResult = AddFriendReq()
            return self
        }
        override public func clone() throws -> AddFriendReq.Builder {
            return try AddFriendReq.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AddFriendReq {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AddFriendReq {
            let returnMe:AddFriendReq = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AddFriendReq) throws -> AddFriendReq.Builder {
            if other == AddFriendReq() {
                return self
            }
            if other.hasTargetId {
                targetId = other.targetId
            }
            if other.hasExtMsg {
                extMsg = other.extMsg
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AddFriendReq.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendReq.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    targetId = try codedInputStream.readString()

                case 18:
                    extMsg = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AddFriendReq.Builder {
            let resultDecodedBuilder = AddFriendReq.Builder()
            if let jsonValueTargetId = jsonMap["targetId"] as? String {
                resultDecodedBuilder.targetId = jsonValueTargetId
            }
            if let jsonValueExtMsg = jsonMap["extMsg"] as? String {
                resultDecodedBuilder.extMsg = jsonValueExtMsg
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AddFriendReq.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AddFriendReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ReceiveFriendReq : GeneratedMessage {
    public typealias BuilderType = ReceiveFriendReq.Builder

    public static func == (lhs: ReceiveFriendReq, rhs: ReceiveFriendReq) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasIsReceive == rhs.hasIsReceive) && (!lhs.hasIsReceive || lhs.isReceive == rhs.isReceive)
        fieldCheck = fieldCheck && (lhs.hasTargetUid == rhs.hasTargetUid) && (!lhs.hasTargetUid || lhs.targetUid == rhs.targetUid)
        fieldCheck = fieldCheck && (lhs.hasExtMsg == rhs.hasExtMsg) && (!lhs.hasExtMsg || lhs.extMsg == rhs.extMsg)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var isReceive:Bool! = nil
    public fileprivate(set) var hasIsReceive:Bool = false

    public fileprivate(set) var targetUid:String! = nil
    public fileprivate(set) var hasTargetUid:Bool = false

    public fileprivate(set) var extMsg:String! = nil
    public fileprivate(set) var hasExtMsg:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasIsReceive {
            try codedOutputStream.writeBool(fieldNumber: 1, value:isReceive)
        }
        if hasTargetUid {
            try codedOutputStream.writeString(fieldNumber: 2, value:targetUid)
        }
        if hasExtMsg {
            try codedOutputStream.writeString(fieldNumber: 3, value:extMsg)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasIsReceive {
            serialize_size += isReceive.computeBoolSize(fieldNumber: 1)
        }
        if hasTargetUid {
            serialize_size += targetUid.computeStringSize(fieldNumber: 2)
        }
        if hasExtMsg {
            serialize_size += extMsg.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ReceiveFriendReq.Builder {
        return ReceiveFriendReq.classBuilder() as! ReceiveFriendReq.Builder
    }
    public func getBuilder() -> ReceiveFriendReq.Builder {
        return classBuilder() as! ReceiveFriendReq.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ReceiveFriendReq.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ReceiveFriendReq.Builder()
    }
    public func toBuilder() throws -> ReceiveFriendReq.Builder {
        return try ReceiveFriendReq.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ReceiveFriendReq) throws -> ReceiveFriendReq.Builder {
        return try ReceiveFriendReq.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasIsReceive {
            jsonMap["isReceive"] = isReceive
        }
        if hasTargetUid {
            jsonMap["targetUid"] = targetUid
        }
        if hasExtMsg {
            jsonMap["extMsg"] = extMsg
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasIsReceive {
            output += "\(indent) isReceive: \(isReceive) \n"
        }
        if hasTargetUid {
            output += "\(indent) targetUid: \(targetUid) \n"
        }
        if hasExtMsg {
            output += "\(indent) extMsg: \(extMsg) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasIsReceive {
                hashCode = (hashCode &* 31) &+ isReceive.hashValue
            }
            if hasTargetUid {
                hashCode = (hashCode &* 31) &+ targetUid.hashValue
            }
            if hasExtMsg {
                hashCode = (hashCode &* 31) &+ extMsg.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ReceiveFriendReq"
    }
    override public func className() -> String {
        return "ReceiveFriendReq"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ReceiveFriendReq = ReceiveFriendReq()
        public func getMessage() -> ReceiveFriendReq {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var isReceive:Bool {
            get {
                return builderResult.isReceive
            }
            set (value) {
                builderResult.hasIsReceive = true
                builderResult.isReceive = value
            }
        }
        public var hasIsReceive:Bool {
            get {
                return builderResult.hasIsReceive
            }
        }
        @discardableResult
        public func setIsReceive(_ value:Bool) -> ReceiveFriendReq.Builder {
            self.isReceive = value
            return self
        }
        @discardableResult
        public func clearIsReceive() -> ReceiveFriendReq.Builder{
            builderResult.hasIsReceive = false
            builderResult.isReceive = nil
            return self
        }
        public var targetUid:String {
            get {
                return builderResult.targetUid
            }
            set (value) {
                builderResult.hasTargetUid = true
                builderResult.targetUid = value
            }
        }
        public var hasTargetUid:Bool {
            get {
                return builderResult.hasTargetUid
            }
        }
        @discardableResult
        public func setTargetUid(_ value:String) -> ReceiveFriendReq.Builder {
            self.targetUid = value
            return self
        }
        @discardableResult
        public func clearTargetUid() -> ReceiveFriendReq.Builder{
            builderResult.hasTargetUid = false
            builderResult.targetUid = nil
            return self
        }
        public var extMsg:String {
            get {
                return builderResult.extMsg
            }
            set (value) {
                builderResult.hasExtMsg = true
                builderResult.extMsg = value
            }
        }
        public var hasExtMsg:Bool {
            get {
                return builderResult.hasExtMsg
            }
        }
        @discardableResult
        public func setExtMsg(_ value:String) -> ReceiveFriendReq.Builder {
            self.extMsg = value
            return self
        }
        @discardableResult
        public func clearExtMsg() -> ReceiveFriendReq.Builder{
            builderResult.hasExtMsg = false
            builderResult.extMsg = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ReceiveFriendReq.Builder {
            builderResult = ReceiveFriendReq()
            return self
        }
        override public func clone() throws -> ReceiveFriendReq.Builder {
            return try ReceiveFriendReq.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ReceiveFriendReq {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ReceiveFriendReq {
            let returnMe:ReceiveFriendReq = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ReceiveFriendReq) throws -> ReceiveFriendReq.Builder {
            if other == ReceiveFriendReq() {
                return self
            }
            if other.hasIsReceive {
                isReceive = other.isReceive
            }
            if other.hasTargetUid {
                targetUid = other.targetUid
            }
            if other.hasExtMsg {
                extMsg = other.extMsg
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ReceiveFriendReq.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendReq.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    isReceive = try codedInputStream.readBool()

                case 18:
                    targetUid = try codedInputStream.readString()

                case 26:
                    extMsg = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ReceiveFriendReq.Builder {
            let resultDecodedBuilder = ReceiveFriendReq.Builder()
            if let jsonValueIsReceive = jsonMap["isReceive"] as? Bool {
                resultDecodedBuilder.isReceive = jsonValueIsReceive
            }
            if let jsonValueTargetUid = jsonMap["targetUid"] as? String {
                resultDecodedBuilder.targetUid = jsonValueTargetUid
            }
            if let jsonValueExtMsg = jsonMap["extMsg"] as? String {
                resultDecodedBuilder.extMsg = jsonValueExtMsg
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ReceiveFriendReq.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ReceiveFriendReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GetFriendListReq : GeneratedMessage {
    public typealias BuilderType = GetFriendListReq.Builder

    public static func == (lhs: GetFriendListReq, rhs: GetFriendListReq) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPage == rhs.hasPage) && (!lhs.hasPage || lhs.page == rhs.page)
        fieldCheck = fieldCheck && (lhs.hasLimit == rhs.hasLimit) && (!lhs.hasLimit || lhs.limit == rhs.limit)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var page:Int32! = nil
    public fileprivate(set) var hasPage:Bool = false

    public fileprivate(set) var limit:Int32! = nil
    public fileprivate(set) var hasLimit:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPage {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:page)
        }
        if hasLimit {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:limit)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPage {
            serialize_size += page.computeInt32Size(fieldNumber: 1)
        }
        if hasLimit {
            serialize_size += limit.computeInt32Size(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GetFriendListReq.Builder {
        return GetFriendListReq.classBuilder() as! GetFriendListReq.Builder
    }
    public func getBuilder() -> GetFriendListReq.Builder {
        return classBuilder() as! GetFriendListReq.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetFriendListReq.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetFriendListReq.Builder()
    }
    public func toBuilder() throws -> GetFriendListReq.Builder {
        return try GetFriendListReq.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GetFriendListReq) throws -> GetFriendListReq.Builder {
        return try GetFriendListReq.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPage {
            jsonMap["page"] = Int(page)
        }
        if hasLimit {
            jsonMap["limit"] = Int(limit)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPage {
            output += "\(indent) page: \(page) \n"
        }
        if hasLimit {
            output += "\(indent) limit: \(limit) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPage {
                hashCode = (hashCode &* 31) &+ page.hashValue
            }
            if hasLimit {
                hashCode = (hashCode &* 31) &+ limit.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GetFriendListReq"
    }
    override public func className() -> String {
        return "GetFriendListReq"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GetFriendListReq = GetFriendListReq()
        public func getMessage() -> GetFriendListReq {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var page:Int32 {
            get {
                return builderResult.page
            }
            set (value) {
                builderResult.hasPage = true
                builderResult.page = value
            }
        }
        public var hasPage:Bool {
            get {
                return builderResult.hasPage
            }
        }
        @discardableResult
        public func setPage(_ value:Int32) -> GetFriendListReq.Builder {
            self.page = value
            return self
        }
        @discardableResult
        public func clearPage() -> GetFriendListReq.Builder{
            builderResult.hasPage = false
            builderResult.page = nil
            return self
        }
        public var limit:Int32 {
            get {
                return builderResult.limit
            }
            set (value) {
                builderResult.hasLimit = true
                builderResult.limit = value
            }
        }
        public var hasLimit:Bool {
            get {
                return builderResult.hasLimit
            }
        }
        @discardableResult
        public func setLimit(_ value:Int32) -> GetFriendListReq.Builder {
            self.limit = value
            return self
        }
        @discardableResult
        public func clearLimit() -> GetFriendListReq.Builder{
            builderResult.hasLimit = false
            builderResult.limit = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GetFriendListReq.Builder {
            builderResult = GetFriendListReq()
            return self
        }
        override public func clone() throws -> GetFriendListReq.Builder {
            return try GetFriendListReq.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GetFriendListReq {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GetFriendListReq {
            let returnMe:GetFriendListReq = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GetFriendListReq) throws -> GetFriendListReq.Builder {
            if other == GetFriendListReq() {
                return self
            }
            if other.hasPage {
                page = other.page
            }
            if other.hasLimit {
                limit = other.limit
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GetFriendListReq.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetFriendListReq.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    page = try codedInputStream.readInt32()

                case 16:
                    limit = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GetFriendListReq.Builder {
            let resultDecodedBuilder = GetFriendListReq.Builder()
            if let jsonValuePage = jsonMap["page"] as? Int {
                resultDecodedBuilder.page = Int32(jsonValuePage)
            } else if let jsonValuePage = jsonMap["page"] as? String {
                resultDecodedBuilder.page = Int32(jsonValuePage)!
            }
            if let jsonValueLimit = jsonMap["limit"] as? Int {
                resultDecodedBuilder.limit = Int32(jsonValueLimit)
            } else if let jsonValueLimit = jsonMap["limit"] as? String {
                resultDecodedBuilder.limit = Int32(jsonValueLimit)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GetFriendListReq.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GetFriendListReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AddFriendNoti : GeneratedMessage {
    public typealias BuilderType = AddFriendNoti.Builder

    public static func == (lhs: AddFriendNoti, rhs: AddFriendNoti) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasOpId == rhs.hasOpId) && (!lhs.hasOpId || lhs.opId == rhs.opId)
        fieldCheck = fieldCheck && (lhs.hasExtMsg == rhs.hasExtMsg) && (!lhs.hasExtMsg || lhs.extMsg == rhs.extMsg)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var opId:String! = nil
    public fileprivate(set) var hasOpId:Bool = false

    public fileprivate(set) var extMsg:String! = nil
    public fileprivate(set) var hasExtMsg:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasOpId {
            try codedOutputStream.writeString(fieldNumber: 1, value:opId)
        }
        if hasExtMsg {
            try codedOutputStream.writeString(fieldNumber: 2, value:extMsg)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasOpId {
            serialize_size += opId.computeStringSize(fieldNumber: 1)
        }
        if hasExtMsg {
            serialize_size += extMsg.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AddFriendNoti.Builder {
        return AddFriendNoti.classBuilder() as! AddFriendNoti.Builder
    }
    public func getBuilder() -> AddFriendNoti.Builder {
        return classBuilder() as! AddFriendNoti.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AddFriendNoti.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AddFriendNoti.Builder()
    }
    public func toBuilder() throws -> AddFriendNoti.Builder {
        return try AddFriendNoti.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AddFriendNoti) throws -> AddFriendNoti.Builder {
        return try AddFriendNoti.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasOpId {
            jsonMap["opId"] = opId
        }
        if hasExtMsg {
            jsonMap["extMsg"] = extMsg
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasOpId {
            output += "\(indent) opId: \(opId) \n"
        }
        if hasExtMsg {
            output += "\(indent) extMsg: \(extMsg) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasOpId {
                hashCode = (hashCode &* 31) &+ opId.hashValue
            }
            if hasExtMsg {
                hashCode = (hashCode &* 31) &+ extMsg.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AddFriendNoti"
    }
    override public func className() -> String {
        return "AddFriendNoti"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AddFriendNoti = AddFriendNoti()
        public func getMessage() -> AddFriendNoti {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var opId:String {
            get {
                return builderResult.opId
            }
            set (value) {
                builderResult.hasOpId = true
                builderResult.opId = value
            }
        }
        public var hasOpId:Bool {
            get {
                return builderResult.hasOpId
            }
        }
        @discardableResult
        public func setOpId(_ value:String) -> AddFriendNoti.Builder {
            self.opId = value
            return self
        }
        @discardableResult
        public func clearOpId() -> AddFriendNoti.Builder{
            builderResult.hasOpId = false
            builderResult.opId = nil
            return self
        }
        public var extMsg:String {
            get {
                return builderResult.extMsg
            }
            set (value) {
                builderResult.hasExtMsg = true
                builderResult.extMsg = value
            }
        }
        public var hasExtMsg:Bool {
            get {
                return builderResult.hasExtMsg
            }
        }
        @discardableResult
        public func setExtMsg(_ value:String) -> AddFriendNoti.Builder {
            self.extMsg = value
            return self
        }
        @discardableResult
        public func clearExtMsg() -> AddFriendNoti.Builder{
            builderResult.hasExtMsg = false
            builderResult.extMsg = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AddFriendNoti.Builder {
            builderResult = AddFriendNoti()
            return self
        }
        override public func clone() throws -> AddFriendNoti.Builder {
            return try AddFriendNoti.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AddFriendNoti {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AddFriendNoti {
            let returnMe:AddFriendNoti = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AddFriendNoti) throws -> AddFriendNoti.Builder {
            if other == AddFriendNoti() {
                return self
            }
            if other.hasOpId {
                opId = other.opId
            }
            if other.hasExtMsg {
                extMsg = other.extMsg
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AddFriendNoti.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendNoti.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    opId = try codedInputStream.readString()

                case 18:
                    extMsg = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AddFriendNoti.Builder {
            let resultDecodedBuilder = AddFriendNoti.Builder()
            if let jsonValueOpId = jsonMap["opId"] as? String {
                resultDecodedBuilder.opId = jsonValueOpId
            }
            if let jsonValueExtMsg = jsonMap["extMsg"] as? String {
                resultDecodedBuilder.extMsg = jsonValueExtMsg
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AddFriendNoti.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AddFriendNoti.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ReceiveFriendNoti : GeneratedMessage {
    public typealias BuilderType = ReceiveFriendNoti.Builder

    public static func == (lhs: ReceiveFriendNoti, rhs: ReceiveFriendNoti) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasIsReceive == rhs.hasIsReceive) && (!lhs.hasIsReceive || lhs.isReceive == rhs.isReceive)
        fieldCheck = fieldCheck && (lhs.hasOpUid == rhs.hasOpUid) && (!lhs.hasOpUid || lhs.opUid == rhs.opUid)
        fieldCheck = fieldCheck && (lhs.hasExtMsg == rhs.hasExtMsg) && (!lhs.hasExtMsg || lhs.extMsg == rhs.extMsg)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var isReceive:Bool! = nil
    public fileprivate(set) var hasIsReceive:Bool = false

    public fileprivate(set) var opUid:String! = nil
    public fileprivate(set) var hasOpUid:Bool = false

    public fileprivate(set) var extMsg:String! = nil
    public fileprivate(set) var hasExtMsg:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasIsReceive {
            try codedOutputStream.writeBool(fieldNumber: 1, value:isReceive)
        }
        if hasOpUid {
            try codedOutputStream.writeString(fieldNumber: 2, value:opUid)
        }
        if hasExtMsg {
            try codedOutputStream.writeString(fieldNumber: 3, value:extMsg)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasIsReceive {
            serialize_size += isReceive.computeBoolSize(fieldNumber: 1)
        }
        if hasOpUid {
            serialize_size += opUid.computeStringSize(fieldNumber: 2)
        }
        if hasExtMsg {
            serialize_size += extMsg.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ReceiveFriendNoti.Builder {
        return ReceiveFriendNoti.classBuilder() as! ReceiveFriendNoti.Builder
    }
    public func getBuilder() -> ReceiveFriendNoti.Builder {
        return classBuilder() as! ReceiveFriendNoti.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ReceiveFriendNoti.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ReceiveFriendNoti.Builder()
    }
    public func toBuilder() throws -> ReceiveFriendNoti.Builder {
        return try ReceiveFriendNoti.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ReceiveFriendNoti) throws -> ReceiveFriendNoti.Builder {
        return try ReceiveFriendNoti.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasIsReceive {
            jsonMap["isReceive"] = isReceive
        }
        if hasOpUid {
            jsonMap["opUid"] = opUid
        }
        if hasExtMsg {
            jsonMap["extMsg"] = extMsg
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasIsReceive {
            output += "\(indent) isReceive: \(isReceive) \n"
        }
        if hasOpUid {
            output += "\(indent) opUid: \(opUid) \n"
        }
        if hasExtMsg {
            output += "\(indent) extMsg: \(extMsg) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasIsReceive {
                hashCode = (hashCode &* 31) &+ isReceive.hashValue
            }
            if hasOpUid {
                hashCode = (hashCode &* 31) &+ opUid.hashValue
            }
            if hasExtMsg {
                hashCode = (hashCode &* 31) &+ extMsg.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ReceiveFriendNoti"
    }
    override public func className() -> String {
        return "ReceiveFriendNoti"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ReceiveFriendNoti = ReceiveFriendNoti()
        public func getMessage() -> ReceiveFriendNoti {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var isReceive:Bool {
            get {
                return builderResult.isReceive
            }
            set (value) {
                builderResult.hasIsReceive = true
                builderResult.isReceive = value
            }
        }
        public var hasIsReceive:Bool {
            get {
                return builderResult.hasIsReceive
            }
        }
        @discardableResult
        public func setIsReceive(_ value:Bool) -> ReceiveFriendNoti.Builder {
            self.isReceive = value
            return self
        }
        @discardableResult
        public func clearIsReceive() -> ReceiveFriendNoti.Builder{
            builderResult.hasIsReceive = false
            builderResult.isReceive = nil
            return self
        }
        public var opUid:String {
            get {
                return builderResult.opUid
            }
            set (value) {
                builderResult.hasOpUid = true
                builderResult.opUid = value
            }
        }
        public var hasOpUid:Bool {
            get {
                return builderResult.hasOpUid
            }
        }
        @discardableResult
        public func setOpUid(_ value:String) -> ReceiveFriendNoti.Builder {
            self.opUid = value
            return self
        }
        @discardableResult
        public func clearOpUid() -> ReceiveFriendNoti.Builder{
            builderResult.hasOpUid = false
            builderResult.opUid = nil
            return self
        }
        public var extMsg:String {
            get {
                return builderResult.extMsg
            }
            set (value) {
                builderResult.hasExtMsg = true
                builderResult.extMsg = value
            }
        }
        public var hasExtMsg:Bool {
            get {
                return builderResult.hasExtMsg
            }
        }
        @discardableResult
        public func setExtMsg(_ value:String) -> ReceiveFriendNoti.Builder {
            self.extMsg = value
            return self
        }
        @discardableResult
        public func clearExtMsg() -> ReceiveFriendNoti.Builder{
            builderResult.hasExtMsg = false
            builderResult.extMsg = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ReceiveFriendNoti.Builder {
            builderResult = ReceiveFriendNoti()
            return self
        }
        override public func clone() throws -> ReceiveFriendNoti.Builder {
            return try ReceiveFriendNoti.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ReceiveFriendNoti {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ReceiveFriendNoti {
            let returnMe:ReceiveFriendNoti = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ReceiveFriendNoti) throws -> ReceiveFriendNoti.Builder {
            if other == ReceiveFriendNoti() {
                return self
            }
            if other.hasIsReceive {
                isReceive = other.isReceive
            }
            if other.hasOpUid {
                opUid = other.opUid
            }
            if other.hasExtMsg {
                extMsg = other.extMsg
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ReceiveFriendNoti.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendNoti.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    isReceive = try codedInputStream.readBool()

                case 18:
                    opUid = try codedInputStream.readString()

                case 26:
                    extMsg = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ReceiveFriendNoti.Builder {
            let resultDecodedBuilder = ReceiveFriendNoti.Builder()
            if let jsonValueIsReceive = jsonMap["isReceive"] as? Bool {
                resultDecodedBuilder.isReceive = jsonValueIsReceive
            }
            if let jsonValueOpUid = jsonMap["opUid"] as? String {
                resultDecodedBuilder.opUid = jsonValueOpUid
            }
            if let jsonValueExtMsg = jsonMap["extMsg"] as? String {
                resultDecodedBuilder.extMsg = jsonValueExtMsg
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ReceiveFriendNoti.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ReceiveFriendNoti.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GetUserInfoById : GeneratedMessage {
    public typealias BuilderType = GetUserInfoById.Builder

    public static func == (lhs: GetUserInfoById, rhs: GetUserInfoById) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasTargetId == rhs.hasTargetId) && (!lhs.hasTargetId || lhs.targetId == rhs.targetId)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var targetId:String! = nil
    public fileprivate(set) var hasTargetId:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasTargetId {
            try codedOutputStream.writeString(fieldNumber: 1, value:targetId)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasTargetId {
            serialize_size += targetId.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GetUserInfoById.Builder {
        return GetUserInfoById.classBuilder() as! GetUserInfoById.Builder
    }
    public func getBuilder() -> GetUserInfoById.Builder {
        return classBuilder() as! GetUserInfoById.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetUserInfoById.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetUserInfoById.Builder()
    }
    public func toBuilder() throws -> GetUserInfoById.Builder {
        return try GetUserInfoById.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GetUserInfoById) throws -> GetUserInfoById.Builder {
        return try GetUserInfoById.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasTargetId {
            jsonMap["targetId"] = targetId
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasTargetId {
            output += "\(indent) targetId: \(targetId) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTargetId {
                hashCode = (hashCode &* 31) &+ targetId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GetUserInfoById"
    }
    override public func className() -> String {
        return "GetUserInfoById"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GetUserInfoById = GetUserInfoById()
        public func getMessage() -> GetUserInfoById {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var targetId:String {
            get {
                return builderResult.targetId
            }
            set (value) {
                builderResult.hasTargetId = true
                builderResult.targetId = value
            }
        }
        public var hasTargetId:Bool {
            get {
                return builderResult.hasTargetId
            }
        }
        @discardableResult
        public func setTargetId(_ value:String) -> GetUserInfoById.Builder {
            self.targetId = value
            return self
        }
        @discardableResult
        public func clearTargetId() -> GetUserInfoById.Builder{
            builderResult.hasTargetId = false
            builderResult.targetId = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GetUserInfoById.Builder {
            builderResult = GetUserInfoById()
            return self
        }
        override public func clone() throws -> GetUserInfoById.Builder {
            return try GetUserInfoById.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GetUserInfoById {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GetUserInfoById {
            let returnMe:GetUserInfoById = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GetUserInfoById) throws -> GetUserInfoById.Builder {
            if other == GetUserInfoById() {
                return self
            }
            if other.hasTargetId {
                targetId = other.targetId
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GetUserInfoById.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetUserInfoById.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    targetId = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GetUserInfoById.Builder {
            let resultDecodedBuilder = GetUserInfoById.Builder()
            if let jsonValueTargetId = jsonMap["targetId"] as? String {
                resultDecodedBuilder.targetId = jsonValueTargetId
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GetUserInfoById.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GetUserInfoById.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class UserInfoRes : GeneratedMessage {
    public typealias BuilderType = UserInfoRes.Builder

    public static func == (lhs: UserInfoRes, rhs: UserInfoRes) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUserInfo == rhs.hasUserInfo) && (!lhs.hasUserInfo || lhs.userInfo == rhs.userInfo)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var userInfo:UserInfo!
    public fileprivate(set) var hasUserInfo:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUserInfo {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:userInfo)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUserInfo {
            if let varSizeuserInfo = userInfo?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeuserInfo
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UserInfoRes.Builder {
        return UserInfoRes.classBuilder() as! UserInfoRes.Builder
    }
    public func getBuilder() -> UserInfoRes.Builder {
        return classBuilder() as! UserInfoRes.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfoRes.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfoRes.Builder()
    }
    public func toBuilder() throws -> UserInfoRes.Builder {
        return try UserInfoRes.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UserInfoRes) throws -> UserInfoRes.Builder {
        return try UserInfoRes.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUserInfo {
            jsonMap["userInfo"] = try userInfo.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserInfoRes {
        return try UserInfoRes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> UserInfoRes {
        return try UserInfoRes.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUserInfo {
            output += "\(indent) userInfo {\n"
            if let outDescUserInfo = userInfo {
                output += try outDescUserInfo.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUserInfo {
                if let hashValueuserInfo = userInfo?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueuserInfo
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UserInfoRes"
    }
    override public func className() -> String {
        return "UserInfoRes"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UserInfoRes = UserInfoRes()
        public func getMessage() -> UserInfoRes {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var userInfo:UserInfo! {
            get {
                if userInfoBuilder_ != nil {
                    builderResult.userInfo = userInfoBuilder_.getMessage()
                }
                return builderResult.userInfo
            }
            set (value) {
                builderResult.hasUserInfo = value != nil
                builderResult.userInfo = value
            }
        }
        public var hasUserInfo:Bool {
            get {
                return builderResult.hasUserInfo
            }
        }
        fileprivate var userInfoBuilder_:UserInfo.Builder! {
            didSet {
                builderResult.hasUserInfo = true
            }
        }
        public func getUserInfoBuilder() -> UserInfo.Builder {
            if userInfoBuilder_ == nil {
                userInfoBuilder_ = UserInfo.Builder()
                builderResult.userInfo = userInfoBuilder_.getMessage()
                if userInfo != nil {
                    try! userInfoBuilder_.mergeFrom(other: userInfo)
                }
            }
            return userInfoBuilder_
        }
        @discardableResult
        public func setUserInfo(_ value:UserInfo!) -> UserInfoRes.Builder {
            self.userInfo = value
            return self
        }
        @discardableResult
        public func mergeUserInfo(value:UserInfo) throws -> UserInfoRes.Builder {
            if builderResult.hasUserInfo {
                builderResult.userInfo = try UserInfo.builderWithPrototype(prototype:builderResult.userInfo).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.userInfo = value
            }
            builderResult.hasUserInfo = true
            return self
        }
        @discardableResult
        public func clearUserInfo() -> UserInfoRes.Builder {
            userInfoBuilder_ = nil
            builderResult.hasUserInfo = false
            builderResult.userInfo = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UserInfoRes.Builder {
            builderResult = UserInfoRes()
            return self
        }
        override public func clone() throws -> UserInfoRes.Builder {
            return try UserInfoRes.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserInfoRes {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UserInfoRes {
            let returnMe:UserInfoRes = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UserInfoRes) throws -> UserInfoRes.Builder {
            if other == UserInfoRes() {
                return self
            }
            if (other.hasUserInfo) {
                try mergeUserInfo(value: other.userInfo)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserInfoRes.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoRes.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:UserInfo.Builder = UserInfo.Builder()
                    if hasUserInfo {
                        try subBuilder.mergeFrom(other: userInfo)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    userInfo = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserInfoRes.Builder {
            let resultDecodedBuilder = UserInfoRes.Builder()
            if let jsonValueUserInfo = jsonMap["userInfo"] as? Dictionary<String,Any> {
                resultDecodedBuilder.userInfo = try UserInfo.Builder.decodeToBuilder(jsonMap:jsonValueUserInfo).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UserInfoRes.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UserInfoRes.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class UserInfoListRes : GeneratedMessage {
    public typealias BuilderType = UserInfoListRes.Builder

    public static func == (lhs: UserInfoListRes, rhs: UserInfoListRes) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUserList == rhs.hasUserList) && (!lhs.hasUserList || lhs.userList == rhs.userList)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var userList:UserInfo!
    public fileprivate(set) var hasUserList:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUserList {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:userList)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUserList {
            if let varSizeuserList = userList?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeuserList
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UserInfoListRes.Builder {
        return UserInfoListRes.classBuilder() as! UserInfoListRes.Builder
    }
    public func getBuilder() -> UserInfoListRes.Builder {
        return classBuilder() as! UserInfoListRes.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfoListRes.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserInfoListRes.Builder()
    }
    public func toBuilder() throws -> UserInfoListRes.Builder {
        return try UserInfoListRes.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UserInfoListRes) throws -> UserInfoListRes.Builder {
        return try UserInfoListRes.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUserList {
            jsonMap["userList"] = try userList.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUserList {
            output += "\(indent) userList {\n"
            if let outDescUserList = userList {
                output += try outDescUserList.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUserList {
                if let hashValueuserList = userList?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueuserList
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UserInfoListRes"
    }
    override public func className() -> String {
        return "UserInfoListRes"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UserInfoListRes = UserInfoListRes()
        public func getMessage() -> UserInfoListRes {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var userList:UserInfo! {
            get {
                if userListBuilder_ != nil {
                    builderResult.userList = userListBuilder_.getMessage()
                }
                return builderResult.userList
            }
            set (value) {
                builderResult.hasUserList = value != nil
                builderResult.userList = value
            }
        }
        public var hasUserList:Bool {
            get {
                return builderResult.hasUserList
            }
        }
        fileprivate var userListBuilder_:UserInfo.Builder! {
            didSet {
                builderResult.hasUserList = true
            }
        }
        public func getUserListBuilder() -> UserInfo.Builder {
            if userListBuilder_ == nil {
                userListBuilder_ = UserInfo.Builder()
                builderResult.userList = userListBuilder_.getMessage()
                if userList != nil {
                    try! userListBuilder_.mergeFrom(other: userList)
                }
            }
            return userListBuilder_
        }
        @discardableResult
        public func setUserList(_ value:UserInfo!) -> UserInfoListRes.Builder {
            self.userList = value
            return self
        }
        @discardableResult
        public func mergeUserList(value:UserInfo) throws -> UserInfoListRes.Builder {
            if builderResult.hasUserList {
                builderResult.userList = try UserInfo.builderWithPrototype(prototype:builderResult.userList).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.userList = value
            }
            builderResult.hasUserList = true
            return self
        }
        @discardableResult
        public func clearUserList() -> UserInfoListRes.Builder {
            userListBuilder_ = nil
            builderResult.hasUserList = false
            builderResult.userList = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UserInfoListRes.Builder {
            builderResult = UserInfoListRes()
            return self
        }
        override public func clone() throws -> UserInfoListRes.Builder {
            return try UserInfoListRes.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserInfoListRes {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UserInfoListRes {
            let returnMe:UserInfoListRes = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UserInfoListRes) throws -> UserInfoListRes.Builder {
            if other == UserInfoListRes() {
                return self
            }
            if (other.hasUserList) {
                try mergeUserList(value: other.userList)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserInfoListRes.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoListRes.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:UserInfo.Builder = UserInfo.Builder()
                    if hasUserList {
                        try subBuilder.mergeFrom(other: userList)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    userList = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserInfoListRes.Builder {
            let resultDecodedBuilder = UserInfoListRes.Builder()
            if let jsonValueUserList = jsonMap["userList"] as? Dictionary<String,Any> {
                resultDecodedBuilder.userList = try UserInfo.Builder.decodeToBuilder(jsonMap:jsonValueUserList).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UserInfoListRes.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UserInfoListRes.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension AddFriendReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AddFriendReq> {
        var mergedArray = Array<AddFriendReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AddFriendReq? {
        return try AddFriendReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendReq {
        return try AddFriendReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "targetId": return self.targetId
        case "extMsg": return self.extMsg
        default: return nil
        }
    }
}
extension AddFriendReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = AddFriendReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "targetId": return self.targetId
            case "extMsg": return self.extMsg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "targetId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.targetId = newSubscriptValue
            case "extMsg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.extMsg = newSubscriptValue
            default: return
            }
        }
    }
}
extension ReceiveFriendReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ReceiveFriendReq> {
        var mergedArray = Array<ReceiveFriendReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ReceiveFriendReq? {
        return try ReceiveFriendReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendReq {
        return try ReceiveFriendReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "isReceive": return self.isReceive
        case "targetUid": return self.targetUid
        case "extMsg": return self.extMsg
        default: return nil
        }
    }
}
extension ReceiveFriendReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ReceiveFriendReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "isReceive": return self.isReceive
            case "targetUid": return self.targetUid
            case "extMsg": return self.extMsg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "isReceive":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isReceive = newSubscriptValue
            case "targetUid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.targetUid = newSubscriptValue
            case "extMsg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.extMsg = newSubscriptValue
            default: return
            }
        }
    }
}
extension GetFriendListReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GetFriendListReq> {
        var mergedArray = Array<GetFriendListReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GetFriendListReq? {
        return try GetFriendListReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetFriendListReq {
        return try GetFriendListReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "page": return self.page
        case "limit": return self.limit
        default: return nil
        }
    }
}
extension GetFriendListReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = GetFriendListReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "page": return self.page
            case "limit": return self.limit
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "page":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.page = newSubscriptValue
            case "limit":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.limit = newSubscriptValue
            default: return
            }
        }
    }
}
extension AddFriendNoti: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AddFriendNoti> {
        var mergedArray = Array<AddFriendNoti>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AddFriendNoti? {
        return try AddFriendNoti.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddFriendNoti {
        return try AddFriendNoti.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "opId": return self.opId
        case "extMsg": return self.extMsg
        default: return nil
        }
    }
}
extension AddFriendNoti.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = AddFriendNoti
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "opId": return self.opId
            case "extMsg": return self.extMsg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "opId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opId = newSubscriptValue
            case "extMsg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.extMsg = newSubscriptValue
            default: return
            }
        }
    }
}
extension ReceiveFriendNoti: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ReceiveFriendNoti> {
        var mergedArray = Array<ReceiveFriendNoti>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ReceiveFriendNoti? {
        return try ReceiveFriendNoti.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReceiveFriendNoti {
        return try ReceiveFriendNoti.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "isReceive": return self.isReceive
        case "opUid": return self.opUid
        case "extMsg": return self.extMsg
        default: return nil
        }
    }
}
extension ReceiveFriendNoti.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ReceiveFriendNoti
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "isReceive": return self.isReceive
            case "opUid": return self.opUid
            case "extMsg": return self.extMsg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "isReceive":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isReceive = newSubscriptValue
            case "opUid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opUid = newSubscriptValue
            case "extMsg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.extMsg = newSubscriptValue
            default: return
            }
        }
    }
}
extension GetUserInfoById: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GetUserInfoById> {
        var mergedArray = Array<GetUserInfoById>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GetUserInfoById? {
        return try GetUserInfoById.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetUserInfoById {
        return try GetUserInfoById.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "targetId": return self.targetId
        default: return nil
        }
    }
}
extension GetUserInfoById.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = GetUserInfoById
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "targetId": return self.targetId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "targetId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.targetId = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserInfoRes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserInfoRes> {
        var mergedArray = Array<UserInfoRes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserInfoRes? {
        return try UserInfoRes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoRes {
        return try UserInfoRes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userInfo": return self.userInfo
        default: return nil
        }
    }
}
extension UserInfoRes.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserInfoRes
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userInfo": return self.userInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userInfo":
                guard let newSubscriptValue = newSubscriptValue as? UserInfo else {
                    return
                }
                self.userInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserInfoListRes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserInfoListRes> {
        var mergedArray = Array<UserInfoListRes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserInfoListRes? {
        return try UserInfoListRes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(data: data, extensionRegistry:FriendsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserInfoListRes {
        return try UserInfoListRes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userList": return self.userList
        default: return nil
        }
    }
}
extension UserInfoListRes.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserInfoListRes
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userList": return self.userList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userList":
                guard let newSubscriptValue = newSubscriptValue as? UserInfo else {
                    return
                }
                self.userList = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
