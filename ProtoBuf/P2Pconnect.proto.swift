/// Generated by the Protocol Buffers 3.5.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "p2p_connect.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct P2PConnectRoot {
    public static let `default` = P2PConnectRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}



//Enum type declaration start 

public enum EnumP2PType:Int32, GeneratedEnum {
    /// 发起p2p连接请求
    case enumP2PTypeConnectRequest = 0

    ///  接受者 上报自己的信息
    case enumP2PTypePostIp = 2
    public func toString() -> String {
        switch self {
        case .enumP2PTypeConnectRequest: return "enum_p2p_type_connect_request"
        case .enumP2PTypePostIp: return "enum_p2p_type_post_ip"
        }
    }
    public static func fromString(_ str:String) throws -> EnumP2PType {
        switch str {
        case "enum_p2p_type_connect_request":    return .enumP2PTypeConnectRequest
        case "enum_p2p_type_post_ip":    return .enumP2PTypePostIp
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .enumP2PTypeConnectRequest: return ".enumP2PTypeConnectRequest"
        case .enumP2PTypePostIp: return ".enumP2PTypePostIp"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:EnumP2PType, rhs:EnumP2PType) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 

final public class P2PConnect : GeneratedMessage {
    public typealias BuilderType = P2PConnect.Builder

    public static func == (lhs: P2PConnect, rhs: P2PConnect) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var type:EnumP2PType = EnumP2PType.enumP2PTypeConnectRequest
    public fileprivate(set) var hasType:Bool = false
    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasType {
            try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 2, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasType) {
            serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PConnect.Builder {
        return P2PConnect.classBuilder() as! P2PConnect.Builder
    }
    public func getBuilder() -> P2PConnect.Builder {
        return classBuilder() as! P2PConnect.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PConnect.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PConnect.Builder()
    }
    public func toBuilder() throws -> P2PConnect.Builder {
        return try P2PConnect.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PConnect) throws -> P2PConnect.Builder {
        return try P2PConnect.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasType {
            jsonMap["type"] = type.toString()
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PConnect {
        return try P2PConnect.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PConnect {
        return try P2PConnect.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if (hasType) {
            output += "\(indent) type: \(type.description)\n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasType {
                 hashCode = (hashCode &* 31) &+ type.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PConnect"
    }
    override public func className() -> String {
        return "P2PConnect"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PConnect = P2PConnect()
        public func getMessage() -> P2PConnect {
            return builderResult
        }

        required override public init () {
            super.init()
        }
            public var type:EnumP2PType {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool{
                get {
                    return builderResult.hasType
                }
            }
        @discardableResult
            public func setType(_ value:EnumP2PType) -> P2PConnect.Builder {
              self.type = value
              return self
            }
        @discardableResult
            public func clearType() -> P2PConnect.Builder {
               builderResult.hasType = false
               builderResult.type = .enumP2PTypeConnectRequest
               return self
            }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> P2PConnect.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> P2PConnect.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PConnect.Builder {
            builderResult = P2PConnect()
            return self
        }
        override public func clone() throws -> P2PConnect.Builder {
            return try P2PConnect.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PConnect {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PConnect {
            let returnMe:P2PConnect = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PConnect) throws -> P2PConnect.Builder {
            if other == P2PConnect() {
                return self
            }
            if other.hasType {
                type = other.type
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PConnect.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnect.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    let valueInttype = try codedInputStream.readEnum()
                    if let enumstype = EnumP2PType(rawValue:valueInttype){
                        type = enumstype
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                    }

                case 18:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PConnect.Builder {
            let resultDecodedBuilder = P2PConnect.Builder()
            if let jsonValueType = jsonMap["type"] as? String {
                resultDecodedBuilder.type = try EnumP2PType.fromString(jsonValueType)
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PConnect.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PConnect.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class P2PconnectRequest : GeneratedMessage {
    public typealias BuilderType = P2PconnectRequest.Builder

    public static func == (lhs: P2PconnectRequest, rhs: P2PconnectRequest) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUid == rhs.hasUid) && (!lhs.hasUid || lhs.uid == rhs.uid)
        fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
        fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
        fieldCheck = fieldCheck && (lhs.hasTargetUid == rhs.hasTargetUid) && (!lhs.hasTargetUid || lhs.targetUid == rhs.targetUid)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var uid:UInt32! = nil
    public fileprivate(set) var hasUid:Bool = false

    /// 自己的ip
    public fileprivate(set) var ip:String! = nil
    public fileprivate(set) var hasIp:Bool = false

    /// 用于建立连接的端口
    public fileprivate(set) var port:Int32! = nil
    public fileprivate(set) var hasPort:Bool = false

    /// 建立连接的目标uid
    public fileprivate(set) var targetUid:UInt32! = nil
    public fileprivate(set) var hasTargetUid:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUid {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:uid)
        }
        if hasIp {
            try codedOutputStream.writeString(fieldNumber: 2, value:ip)
        }
        if hasPort {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:port)
        }
        if hasTargetUid {
            try codedOutputStream.writeUInt32(fieldNumber: 4, value:targetUid)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUid {
            serialize_size += uid.computeUInt32Size(fieldNumber: 1)
        }
        if hasIp {
            serialize_size += ip.computeStringSize(fieldNumber: 2)
        }
        if hasPort {
            serialize_size += port.computeInt32Size(fieldNumber: 3)
        }
        if hasTargetUid {
            serialize_size += targetUid.computeUInt32Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PconnectRequest.Builder {
        return P2PconnectRequest.classBuilder() as! P2PconnectRequest.Builder
    }
    public func getBuilder() -> P2PconnectRequest.Builder {
        return classBuilder() as! P2PconnectRequest.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PconnectRequest.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PconnectRequest.Builder()
    }
    public func toBuilder() throws -> P2PconnectRequest.Builder {
        return try P2PconnectRequest.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PconnectRequest) throws -> P2PconnectRequest.Builder {
        return try P2PconnectRequest.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUid {
            jsonMap["uid"] = UInt(uid)
        }
        if hasIp {
            jsonMap["ip"] = ip
        }
        if hasPort {
            jsonMap["port"] = Int(port)
        }
        if hasTargetUid {
            jsonMap["targetUid"] = UInt(targetUid)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUid {
            output += "\(indent) uid: \(uid) \n"
        }
        if hasIp {
            output += "\(indent) ip: \(ip) \n"
        }
        if hasPort {
            output += "\(indent) port: \(port) \n"
        }
        if hasTargetUid {
            output += "\(indent) targetUid: \(targetUid) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUid {
                hashCode = (hashCode &* 31) &+ uid.hashValue
            }
            if hasIp {
                hashCode = (hashCode &* 31) &+ ip.hashValue
            }
            if hasPort {
                hashCode = (hashCode &* 31) &+ port.hashValue
            }
            if hasTargetUid {
                hashCode = (hashCode &* 31) &+ targetUid.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PconnectRequest"
    }
    override public func className() -> String {
        return "P2PconnectRequest"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PconnectRequest = P2PconnectRequest()
        public func getMessage() -> P2PconnectRequest {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var uid:UInt32 {
            get {
                return builderResult.uid
            }
            set (value) {
                builderResult.hasUid = true
                builderResult.uid = value
            }
        }
        public var hasUid:Bool {
            get {
                return builderResult.hasUid
            }
        }
        @discardableResult
        public func setUid(_ value:UInt32) -> P2PconnectRequest.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> P2PconnectRequest.Builder{
            builderResult.hasUid = false
            builderResult.uid = nil
            return self
        }
        /// 自己的ip
        public var ip:String {
            get {
                return builderResult.ip
            }
            set (value) {
                builderResult.hasIp = true
                builderResult.ip = value
            }
        }
        public var hasIp:Bool {
            get {
                return builderResult.hasIp
            }
        }
        @discardableResult
        public func setIp(_ value:String) -> P2PconnectRequest.Builder {
            self.ip = value
            return self
        }
        @discardableResult
        public func clearIp() -> P2PconnectRequest.Builder{
            builderResult.hasIp = false
            builderResult.ip = nil
            return self
        }
        /// 用于建立连接的端口
        public var port:Int32 {
            get {
                return builderResult.port
            }
            set (value) {
                builderResult.hasPort = true
                builderResult.port = value
            }
        }
        public var hasPort:Bool {
            get {
                return builderResult.hasPort
            }
        }
        @discardableResult
        public func setPort(_ value:Int32) -> P2PconnectRequest.Builder {
            self.port = value
            return self
        }
        @discardableResult
        public func clearPort() -> P2PconnectRequest.Builder{
            builderResult.hasPort = false
            builderResult.port = nil
            return self
        }
        /// 建立连接的目标uid
        public var targetUid:UInt32 {
            get {
                return builderResult.targetUid
            }
            set (value) {
                builderResult.hasTargetUid = true
                builderResult.targetUid = value
            }
        }
        public var hasTargetUid:Bool {
            get {
                return builderResult.hasTargetUid
            }
        }
        @discardableResult
        public func setTargetUid(_ value:UInt32) -> P2PconnectRequest.Builder {
            self.targetUid = value
            return self
        }
        @discardableResult
        public func clearTargetUid() -> P2PconnectRequest.Builder{
            builderResult.hasTargetUid = false
            builderResult.targetUid = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PconnectRequest.Builder {
            builderResult = P2PconnectRequest()
            return self
        }
        override public func clone() throws -> P2PconnectRequest.Builder {
            return try P2PconnectRequest.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PconnectRequest {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PconnectRequest {
            let returnMe:P2PconnectRequest = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PconnectRequest) throws -> P2PconnectRequest.Builder {
            if other == P2PconnectRequest() {
                return self
            }
            if other.hasUid {
                uid = other.uid
            }
            if other.hasIp {
                ip = other.ip
            }
            if other.hasPort {
                port = other.port
            }
            if other.hasTargetUid {
                targetUid = other.targetUid
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PconnectRequest.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectRequest.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    uid = try codedInputStream.readUInt32()

                case 18:
                    ip = try codedInputStream.readString()

                case 24:
                    port = try codedInputStream.readInt32()

                case 32:
                    targetUid = try codedInputStream.readUInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PconnectRequest.Builder {
            let resultDecodedBuilder = P2PconnectRequest.Builder()
            if let jsonValueUid = jsonMap["uid"] as? UInt {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)
            } else if let jsonValueUid = jsonMap["uid"] as? String {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)!
            }
            if let jsonValueIp = jsonMap["ip"] as? String {
                resultDecodedBuilder.ip = jsonValueIp
            }
            if let jsonValuePort = jsonMap["port"] as? Int {
                resultDecodedBuilder.port = Int32(jsonValuePort)
            } else if let jsonValuePort = jsonMap["port"] as? String {
                resultDecodedBuilder.port = Int32(jsonValuePort)!
            }
            if let jsonValueTargetUid = jsonMap["targetUid"] as? UInt {
                resultDecodedBuilder.targetUid = UInt32(jsonValueTargetUid)
            } else if let jsonValueTargetUid = jsonMap["targetUid"] as? String {
                resultDecodedBuilder.targetUid = UInt32(jsonValueTargetUid)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PconnectRequest.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PconnectRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// 如果在线会立即通知对方 存在且离线 当设备上线时收到通知，上报后保存
final public class P2PconnectResponse : GeneratedMessage {
    public typealias BuilderType = P2PconnectResponse.Builder

    public static func == (lhs: P2PconnectResponse, rhs: P2PconnectResponse) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasIsOnline == rhs.hasIsOnline) && (!lhs.hasIsOnline || lhs.isOnline == rhs.isOnline)
        fieldCheck = fieldCheck && (lhs.hasIsExit == rhs.hasIsExit) && (!lhs.hasIsExit || lhs.isExit == rhs.isExit)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    /// 是否在线
    public fileprivate(set) var isOnline:Bool! = nil
    public fileprivate(set) var hasIsOnline:Bool = false

    /// 是否存在对应uid的账号 先在在线的sock列表中找，再在数据库中查找，找到为true
    public fileprivate(set) var isExit:Bool! = nil
    public fileprivate(set) var hasIsExit:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasIsOnline {
            try codedOutputStream.writeBool(fieldNumber: 1, value:isOnline)
        }
        if hasIsExit {
            try codedOutputStream.writeBool(fieldNumber: 2, value:isExit)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasIsOnline {
            serialize_size += isOnline.computeBoolSize(fieldNumber: 1)
        }
        if hasIsExit {
            serialize_size += isExit.computeBoolSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PconnectResponse.Builder {
        return P2PconnectResponse.classBuilder() as! P2PconnectResponse.Builder
    }
    public func getBuilder() -> P2PconnectResponse.Builder {
        return classBuilder() as! P2PconnectResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PconnectResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PconnectResponse.Builder()
    }
    public func toBuilder() throws -> P2PconnectResponse.Builder {
        return try P2PconnectResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PconnectResponse) throws -> P2PconnectResponse.Builder {
        return try P2PconnectResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasIsOnline {
            jsonMap["isOnline"] = isOnline
        }
        if hasIsExit {
            jsonMap["isExit"] = isExit
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasIsOnline {
            output += "\(indent) isOnline: \(isOnline) \n"
        }
        if hasIsExit {
            output += "\(indent) isExit: \(isExit) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasIsOnline {
                hashCode = (hashCode &* 31) &+ isOnline.hashValue
            }
            if hasIsExit {
                hashCode = (hashCode &* 31) &+ isExit.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PconnectResponse"
    }
    override public func className() -> String {
        return "P2PconnectResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PconnectResponse = P2PconnectResponse()
        public func getMessage() -> P2PconnectResponse {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        /// 是否在线
        public var isOnline:Bool {
            get {
                return builderResult.isOnline
            }
            set (value) {
                builderResult.hasIsOnline = true
                builderResult.isOnline = value
            }
        }
        public var hasIsOnline:Bool {
            get {
                return builderResult.hasIsOnline
            }
        }
        @discardableResult
        public func setIsOnline(_ value:Bool) -> P2PconnectResponse.Builder {
            self.isOnline = value
            return self
        }
        @discardableResult
        public func clearIsOnline() -> P2PconnectResponse.Builder{
            builderResult.hasIsOnline = false
            builderResult.isOnline = nil
            return self
        }
        /// 是否存在对应uid的账号 先在在线的sock列表中找，再在数据库中查找，找到为true
        public var isExit:Bool {
            get {
                return builderResult.isExit
            }
            set (value) {
                builderResult.hasIsExit = true
                builderResult.isExit = value
            }
        }
        public var hasIsExit:Bool {
            get {
                return builderResult.hasIsExit
            }
        }
        @discardableResult
        public func setIsExit(_ value:Bool) -> P2PconnectResponse.Builder {
            self.isExit = value
            return self
        }
        @discardableResult
        public func clearIsExit() -> P2PconnectResponse.Builder{
            builderResult.hasIsExit = false
            builderResult.isExit = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PconnectResponse.Builder {
            builderResult = P2PconnectResponse()
            return self
        }
        override public func clone() throws -> P2PconnectResponse.Builder {
            return try P2PconnectResponse.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PconnectResponse {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PconnectResponse {
            let returnMe:P2PconnectResponse = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PconnectResponse) throws -> P2PconnectResponse.Builder {
            if other == P2PconnectResponse() {
                return self
            }
            if other.hasIsOnline {
                isOnline = other.isOnline
            }
            if other.hasIsExit {
                isExit = other.isExit
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PconnectResponse.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectResponse.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    isOnline = try codedInputStream.readBool()

                case 16:
                    isExit = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PconnectResponse.Builder {
            let resultDecodedBuilder = P2PconnectResponse.Builder()
            if let jsonValueIsOnline = jsonMap["isOnline"] as? Bool {
                resultDecodedBuilder.isOnline = jsonValueIsOnline
            }
            if let jsonValueIsExit = jsonMap["isExit"] as? Bool {
                resultDecodedBuilder.isExit = jsonValueIsExit
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PconnectResponse.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PconnectResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// 如果被连接者接受到时离线 则不用上报
final public class P2PPostIpRequest : GeneratedMessage {
    public typealias BuilderType = P2PPostIpRequest.Builder

    public static func == (lhs: P2PPostIpRequest, rhs: P2PPostIpRequest) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSponsorUid == rhs.hasSponsorUid) && (!lhs.hasSponsorUid || lhs.sponsorUid == rhs.sponsorUid)
        fieldCheck = fieldCheck && (lhs.hasUid == rhs.hasUid) && (!lhs.hasUid || lhs.uid == rhs.uid)
        fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
        fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
        fieldCheck = fieldCheck && (lhs.hasIsReady == rhs.hasIsReady) && (!lhs.hasIsReady || lhs.isReady == rhs.isReady)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    /// 发起者uid
    public fileprivate(set) var sponsorUid:UInt32! = nil
    public fileprivate(set) var hasSponsorUid:Bool = false

    public fileprivate(set) var uid:UInt32! = nil
    public fileprivate(set) var hasUid:Bool = false

    public fileprivate(set) var ip:String! = nil
    public fileprivate(set) var hasIp:Bool = false

    public fileprivate(set) var port:Int32! = nil
    public fileprivate(set) var hasPort:Bool = false

    public fileprivate(set) var isReady:Bool! = nil
    public fileprivate(set) var hasIsReady:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSponsorUid {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:sponsorUid)
        }
        if hasUid {
            try codedOutputStream.writeUInt32(fieldNumber: 2, value:uid)
        }
        if hasIp {
            try codedOutputStream.writeString(fieldNumber: 3, value:ip)
        }
        if hasPort {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:port)
        }
        if hasIsReady {
            try codedOutputStream.writeBool(fieldNumber: 5, value:isReady)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSponsorUid {
            serialize_size += sponsorUid.computeUInt32Size(fieldNumber: 1)
        }
        if hasUid {
            serialize_size += uid.computeUInt32Size(fieldNumber: 2)
        }
        if hasIp {
            serialize_size += ip.computeStringSize(fieldNumber: 3)
        }
        if hasPort {
            serialize_size += port.computeInt32Size(fieldNumber: 4)
        }
        if hasIsReady {
            serialize_size += isReady.computeBoolSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PPostIpRequest.Builder {
        return P2PPostIpRequest.classBuilder() as! P2PPostIpRequest.Builder
    }
    public func getBuilder() -> P2PPostIpRequest.Builder {
        return classBuilder() as! P2PPostIpRequest.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PPostIpRequest.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PPostIpRequest.Builder()
    }
    public func toBuilder() throws -> P2PPostIpRequest.Builder {
        return try P2PPostIpRequest.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PPostIpRequest) throws -> P2PPostIpRequest.Builder {
        return try P2PPostIpRequest.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSponsorUid {
            jsonMap["sponsorUid"] = UInt(sponsorUid)
        }
        if hasUid {
            jsonMap["uid"] = UInt(uid)
        }
        if hasIp {
            jsonMap["ip"] = ip
        }
        if hasPort {
            jsonMap["port"] = Int(port)
        }
        if hasIsReady {
            jsonMap["isReady"] = isReady
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSponsorUid {
            output += "\(indent) sponsorUid: \(sponsorUid) \n"
        }
        if hasUid {
            output += "\(indent) uid: \(uid) \n"
        }
        if hasIp {
            output += "\(indent) ip: \(ip) \n"
        }
        if hasPort {
            output += "\(indent) port: \(port) \n"
        }
        if hasIsReady {
            output += "\(indent) isReady: \(isReady) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSponsorUid {
                hashCode = (hashCode &* 31) &+ sponsorUid.hashValue
            }
            if hasUid {
                hashCode = (hashCode &* 31) &+ uid.hashValue
            }
            if hasIp {
                hashCode = (hashCode &* 31) &+ ip.hashValue
            }
            if hasPort {
                hashCode = (hashCode &* 31) &+ port.hashValue
            }
            if hasIsReady {
                hashCode = (hashCode &* 31) &+ isReady.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PPostIpRequest"
    }
    override public func className() -> String {
        return "P2PPostIpRequest"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PPostIpRequest = P2PPostIpRequest()
        public func getMessage() -> P2PPostIpRequest {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        /// 发起者uid
        public var sponsorUid:UInt32 {
            get {
                return builderResult.sponsorUid
            }
            set (value) {
                builderResult.hasSponsorUid = true
                builderResult.sponsorUid = value
            }
        }
        public var hasSponsorUid:Bool {
            get {
                return builderResult.hasSponsorUid
            }
        }
        @discardableResult
        public func setSponsorUid(_ value:UInt32) -> P2PPostIpRequest.Builder {
            self.sponsorUid = value
            return self
        }
        @discardableResult
        public func clearSponsorUid() -> P2PPostIpRequest.Builder{
            builderResult.hasSponsorUid = false
            builderResult.sponsorUid = nil
            return self
        }
        public var uid:UInt32 {
            get {
                return builderResult.uid
            }
            set (value) {
                builderResult.hasUid = true
                builderResult.uid = value
            }
        }
        public var hasUid:Bool {
            get {
                return builderResult.hasUid
            }
        }
        @discardableResult
        public func setUid(_ value:UInt32) -> P2PPostIpRequest.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> P2PPostIpRequest.Builder{
            builderResult.hasUid = false
            builderResult.uid = nil
            return self
        }
        public var ip:String {
            get {
                return builderResult.ip
            }
            set (value) {
                builderResult.hasIp = true
                builderResult.ip = value
            }
        }
        public var hasIp:Bool {
            get {
                return builderResult.hasIp
            }
        }
        @discardableResult
        public func setIp(_ value:String) -> P2PPostIpRequest.Builder {
            self.ip = value
            return self
        }
        @discardableResult
        public func clearIp() -> P2PPostIpRequest.Builder{
            builderResult.hasIp = false
            builderResult.ip = nil
            return self
        }
        public var port:Int32 {
            get {
                return builderResult.port
            }
            set (value) {
                builderResult.hasPort = true
                builderResult.port = value
            }
        }
        public var hasPort:Bool {
            get {
                return builderResult.hasPort
            }
        }
        @discardableResult
        public func setPort(_ value:Int32) -> P2PPostIpRequest.Builder {
            self.port = value
            return self
        }
        @discardableResult
        public func clearPort() -> P2PPostIpRequest.Builder{
            builderResult.hasPort = false
            builderResult.port = nil
            return self
        }
        public var isReady:Bool {
            get {
                return builderResult.isReady
            }
            set (value) {
                builderResult.hasIsReady = true
                builderResult.isReady = value
            }
        }
        public var hasIsReady:Bool {
            get {
                return builderResult.hasIsReady
            }
        }
        @discardableResult
        public func setIsReady(_ value:Bool) -> P2PPostIpRequest.Builder {
            self.isReady = value
            return self
        }
        @discardableResult
        public func clearIsReady() -> P2PPostIpRequest.Builder{
            builderResult.hasIsReady = false
            builderResult.isReady = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PPostIpRequest.Builder {
            builderResult = P2PPostIpRequest()
            return self
        }
        override public func clone() throws -> P2PPostIpRequest.Builder {
            return try P2PPostIpRequest.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PPostIpRequest {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PPostIpRequest {
            let returnMe:P2PPostIpRequest = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PPostIpRequest) throws -> P2PPostIpRequest.Builder {
            if other == P2PPostIpRequest() {
                return self
            }
            if other.hasSponsorUid {
                sponsorUid = other.sponsorUid
            }
            if other.hasUid {
                uid = other.uid
            }
            if other.hasIp {
                ip = other.ip
            }
            if other.hasPort {
                port = other.port
            }
            if other.hasIsReady {
                isReady = other.isReady
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PPostIpRequest.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpRequest.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    sponsorUid = try codedInputStream.readUInt32()

                case 16:
                    uid = try codedInputStream.readUInt32()

                case 26:
                    ip = try codedInputStream.readString()

                case 32:
                    port = try codedInputStream.readInt32()

                case 40:
                    isReady = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PPostIpRequest.Builder {
            let resultDecodedBuilder = P2PPostIpRequest.Builder()
            if let jsonValueSponsorUid = jsonMap["sponsorUid"] as? UInt {
                resultDecodedBuilder.sponsorUid = UInt32(jsonValueSponsorUid)
            } else if let jsonValueSponsorUid = jsonMap["sponsorUid"] as? String {
                resultDecodedBuilder.sponsorUid = UInt32(jsonValueSponsorUid)!
            }
            if let jsonValueUid = jsonMap["uid"] as? UInt {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)
            } else if let jsonValueUid = jsonMap["uid"] as? String {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)!
            }
            if let jsonValueIp = jsonMap["ip"] as? String {
                resultDecodedBuilder.ip = jsonValueIp
            }
            if let jsonValuePort = jsonMap["port"] as? Int {
                resultDecodedBuilder.port = Int32(jsonValuePort)
            } else if let jsonValuePort = jsonMap["port"] as? String {
                resultDecodedBuilder.port = Int32(jsonValuePort)!
            }
            if let jsonValueIsReady = jsonMap["isReady"] as? Bool {
                resultDecodedBuilder.isReady = jsonValueIsReady
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PPostIpRequest.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PPostIpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class P2PPostIpResponse : GeneratedMessage {
    public typealias BuilderType = P2PPostIpResponse.Builder

    public static func == (lhs: P2PPostIpResponse, rhs: P2PPostIpResponse) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasIsSuc == rhs.hasIsSuc) && (!lhs.hasIsSuc || lhs.isSuc == rhs.isSuc)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var isSuc:Bool! = nil
    public fileprivate(set) var hasIsSuc:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasIsSuc {
            try codedOutputStream.writeBool(fieldNumber: 1, value:isSuc)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasIsSuc {
            serialize_size += isSuc.computeBoolSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PPostIpResponse.Builder {
        return P2PPostIpResponse.classBuilder() as! P2PPostIpResponse.Builder
    }
    public func getBuilder() -> P2PPostIpResponse.Builder {
        return classBuilder() as! P2PPostIpResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PPostIpResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PPostIpResponse.Builder()
    }
    public func toBuilder() throws -> P2PPostIpResponse.Builder {
        return try P2PPostIpResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PPostIpResponse) throws -> P2PPostIpResponse.Builder {
        return try P2PPostIpResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasIsSuc {
            jsonMap["isSuc"] = isSuc
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasIsSuc {
            output += "\(indent) isSuc: \(isSuc) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasIsSuc {
                hashCode = (hashCode &* 31) &+ isSuc.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PPostIpResponse"
    }
    override public func className() -> String {
        return "P2PPostIpResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PPostIpResponse = P2PPostIpResponse()
        public func getMessage() -> P2PPostIpResponse {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var isSuc:Bool {
            get {
                return builderResult.isSuc
            }
            set (value) {
                builderResult.hasIsSuc = true
                builderResult.isSuc = value
            }
        }
        public var hasIsSuc:Bool {
            get {
                return builderResult.hasIsSuc
            }
        }
        @discardableResult
        public func setIsSuc(_ value:Bool) -> P2PPostIpResponse.Builder {
            self.isSuc = value
            return self
        }
        @discardableResult
        public func clearIsSuc() -> P2PPostIpResponse.Builder{
            builderResult.hasIsSuc = false
            builderResult.isSuc = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PPostIpResponse.Builder {
            builderResult = P2PPostIpResponse()
            return self
        }
        override public func clone() throws -> P2PPostIpResponse.Builder {
            return try P2PPostIpResponse.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PPostIpResponse {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PPostIpResponse {
            let returnMe:P2PPostIpResponse = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PPostIpResponse) throws -> P2PPostIpResponse.Builder {
            if other == P2PPostIpResponse() {
                return self
            }
            if other.hasIsSuc {
                isSuc = other.isSuc
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PPostIpResponse.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpResponse.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    isSuc = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PPostIpResponse.Builder {
            let resultDecodedBuilder = P2PPostIpResponse.Builder()
            if let jsonValueIsSuc = jsonMap["isSuc"] as? Bool {
                resultDecodedBuilder.isSuc = jsonValueIsSuc
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PPostIpResponse.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PPostIpResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension P2PConnect: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PConnect> {
        var mergedArray = Array<P2PConnect>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PConnect? {
        return try P2PConnect.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(data: data, extensionRegistry:P2PConnectRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnect {
        return try P2PConnect.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "body": return self.body
        default: return nil
        }
    }
}
extension P2PConnect.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PConnect
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? EnumP2PType else {
                    return
                }
                self.type = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PconnectRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PconnectRequest> {
        var mergedArray = Array<P2PconnectRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PconnectRequest? {
        return try P2PconnectRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(data: data, extensionRegistry:P2PConnectRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectRequest {
        return try P2PconnectRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uid": return self.uid
        case "ip": return self.ip
        case "port": return self.port
        case "targetUid": return self.targetUid
        default: return nil
        }
    }
}
extension P2PconnectRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PconnectRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uid": return self.uid
            case "ip": return self.ip
            case "port": return self.port
            case "targetUid": return self.targetUid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.uid = newSubscriptValue
            case "ip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.port = newSubscriptValue
            case "targetUid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.targetUid = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PconnectResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PconnectResponse> {
        var mergedArray = Array<P2PconnectResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PconnectResponse? {
        return try P2PconnectResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(data: data, extensionRegistry:P2PConnectRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PconnectResponse {
        return try P2PconnectResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "isOnline": return self.isOnline
        case "isExit": return self.isExit
        default: return nil
        }
    }
}
extension P2PconnectResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PconnectResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "isOnline": return self.isOnline
            case "isExit": return self.isExit
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "isOnline":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isOnline = newSubscriptValue
            case "isExit":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isExit = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PPostIpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PPostIpRequest> {
        var mergedArray = Array<P2PPostIpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PPostIpRequest? {
        return try P2PPostIpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(data: data, extensionRegistry:P2PConnectRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpRequest {
        return try P2PPostIpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sponsorUid": return self.sponsorUid
        case "uid": return self.uid
        case "ip": return self.ip
        case "port": return self.port
        case "isReady": return self.isReady
        default: return nil
        }
    }
}
extension P2PPostIpRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PPostIpRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sponsorUid": return self.sponsorUid
            case "uid": return self.uid
            case "ip": return self.ip
            case "port": return self.port
            case "isReady": return self.isReady
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sponsorUid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sponsorUid = newSubscriptValue
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.uid = newSubscriptValue
            case "ip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.port = newSubscriptValue
            case "isReady":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isReady = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PPostIpResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PPostIpResponse> {
        var mergedArray = Array<P2PPostIpResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PPostIpResponse? {
        return try P2PPostIpResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(data: data, extensionRegistry:P2PConnectRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PPostIpResponse {
        return try P2PPostIpResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "isSuc": return self.isSuc
        default: return nil
        }
    }
}
extension P2PPostIpResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PPostIpResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "isSuc": return self.isSuc
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "isSuc":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isSuc = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
