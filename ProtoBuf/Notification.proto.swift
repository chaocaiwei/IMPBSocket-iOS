/// Generated by the Protocol Buffers 3.5.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "notification.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct NotificationRoot {
    public static let `default` = NotificationRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}



//Enum type declaration start 

public enum EnumNotificationType:Int32, GeneratedEnum {
    case enumNotificationTypeAddfriendReq = 0
    case enumNotificationTypeOfflineMsg = 2
    case enumNotificationTypeCmd = 3
    case enumNotificationTypeP2PReceiveConnectReq = 4
    case enumNotificationTypeP2PConnectReady = 5
    public func toString() -> String {
        switch self {
        case .enumNotificationTypeAddfriendReq: return "enum_notification_type_addfriend_req"
        case .enumNotificationTypeOfflineMsg: return "enum_notification_type_offline_msg"
        case .enumNotificationTypeCmd: return "enum_notification_type_cmd"
        case .enumNotificationTypeP2PReceiveConnectReq: return "enum_notification_type_p2p_receive_connect_req"
        case .enumNotificationTypeP2PConnectReady: return "enum_notification_type_p2p_connect_ready"
        }
    }
    public static func fromString(_ str:String) throws -> EnumNotificationType {
        switch str {
        case "enum_notification_type_addfriend_req":    return .enumNotificationTypeAddfriendReq
        case "enum_notification_type_offline_msg":    return .enumNotificationTypeOfflineMsg
        case "enum_notification_type_cmd":    return .enumNotificationTypeCmd
        case "enum_notification_type_p2p_receive_connect_req":    return .enumNotificationTypeP2PReceiveConnectReq
        case "enum_notification_type_p2p_connect_ready":    return .enumNotificationTypeP2PConnectReady
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .enumNotificationTypeAddfriendReq: return ".enumNotificationTypeAddfriendReq"
        case .enumNotificationTypeOfflineMsg: return ".enumNotificationTypeOfflineMsg"
        case .enumNotificationTypeCmd: return ".enumNotificationTypeCmd"
        case .enumNotificationTypeP2PReceiveConnectReq: return ".enumNotificationTypeP2PReceiveConnectReq"
        case .enumNotificationTypeP2PConnectReady: return ".enumNotificationTypeP2PConnectReady"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:EnumNotificationType, rhs:EnumNotificationType) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 

final public class NotificationMsg : GeneratedMessage {
    public typealias BuilderType = NotificationMsg.Builder

    public static func == (lhs: NotificationMsg, rhs: NotificationMsg) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
        fieldCheck = fieldCheck && (lhs.hasTargetUid == rhs.hasTargetUid) && (!lhs.hasTargetUid || lhs.targetUid == rhs.targetUid)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var type:EnumNotificationType = EnumNotificationType.enumNotificationTypeAddfriendReq
    public fileprivate(set) var hasType:Bool = false
    public fileprivate(set) var targetUid:UInt32! = nil
    public fileprivate(set) var hasTargetUid:Bool = false

    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasType {
            try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
        }
        if hasTargetUid {
            try codedOutputStream.writeUInt32(fieldNumber: 2, value:targetUid)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 3, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasType) {
            serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
        }
        if hasTargetUid {
            serialize_size += targetUid.computeUInt32Size(fieldNumber: 2)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> NotificationMsg.Builder {
        return NotificationMsg.classBuilder() as! NotificationMsg.Builder
    }
    public func getBuilder() -> NotificationMsg.Builder {
        return classBuilder() as! NotificationMsg.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return NotificationMsg.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return NotificationMsg.Builder()
    }
    public func toBuilder() throws -> NotificationMsg.Builder {
        return try NotificationMsg.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:NotificationMsg) throws -> NotificationMsg.Builder {
        return try NotificationMsg.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasType {
            jsonMap["type"] = type.toString()
        }
        if hasTargetUid {
            jsonMap["targetUid"] = UInt(targetUid)
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> NotificationMsg {
        return try NotificationMsg.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> NotificationMsg {
        return try NotificationMsg.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if (hasType) {
            output += "\(indent) type: \(type.description)\n"
        }
        if hasTargetUid {
            output += "\(indent) targetUid: \(targetUid) \n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasType {
                 hashCode = (hashCode &* 31) &+ type.hashValue
            }
            if hasTargetUid {
                hashCode = (hashCode &* 31) &+ targetUid.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "NotificationMsg"
    }
    override public func className() -> String {
        return "NotificationMsg"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:NotificationMsg = NotificationMsg()
        public func getMessage() -> NotificationMsg {
            return builderResult
        }

        required override public init () {
            super.init()
        }
            public var type:EnumNotificationType {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool{
                get {
                    return builderResult.hasType
                }
            }
        @discardableResult
            public func setType(_ value:EnumNotificationType) -> NotificationMsg.Builder {
              self.type = value
              return self
            }
        @discardableResult
            public func clearType() -> NotificationMsg.Builder {
               builderResult.hasType = false
               builderResult.type = .enumNotificationTypeAddfriendReq
               return self
            }
        public var targetUid:UInt32 {
            get {
                return builderResult.targetUid
            }
            set (value) {
                builderResult.hasTargetUid = true
                builderResult.targetUid = value
            }
        }
        public var hasTargetUid:Bool {
            get {
                return builderResult.hasTargetUid
            }
        }
        @discardableResult
        public func setTargetUid(_ value:UInt32) -> NotificationMsg.Builder {
            self.targetUid = value
            return self
        }
        @discardableResult
        public func clearTargetUid() -> NotificationMsg.Builder{
            builderResult.hasTargetUid = false
            builderResult.targetUid = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> NotificationMsg.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> NotificationMsg.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> NotificationMsg.Builder {
            builderResult = NotificationMsg()
            return self
        }
        override public func clone() throws -> NotificationMsg.Builder {
            return try NotificationMsg.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> NotificationMsg {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> NotificationMsg {
            let returnMe:NotificationMsg = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:NotificationMsg) throws -> NotificationMsg.Builder {
            if other == NotificationMsg() {
                return self
            }
            if other.hasType {
                type = other.type
            }
            if other.hasTargetUid {
                targetUid = other.targetUid
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> NotificationMsg.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationMsg.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    let valueInttype = try codedInputStream.readEnum()
                    if let enumstype = EnumNotificationType(rawValue:valueInttype){
                        type = enumstype
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                    }

                case 16:
                    targetUid = try codedInputStream.readUInt32()

                case 26:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> NotificationMsg.Builder {
            let resultDecodedBuilder = NotificationMsg.Builder()
            if let jsonValueType = jsonMap["type"] as? String {
                resultDecodedBuilder.type = try EnumNotificationType.fromString(jsonValueType)
            }
            if let jsonValueTargetUid = jsonMap["targetUid"] as? UInt {
                resultDecodedBuilder.targetUid = UInt32(jsonValueTargetUid)
            } else if let jsonValueTargetUid = jsonMap["targetUid"] as? String {
                resultDecodedBuilder.targetUid = UInt32(jsonValueTargetUid)!
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> NotificationMsg.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try NotificationMsg.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// 收到其他终端的p2p连接请求 收到后启动一个端口监听
final public class P2PReceiveConnectNotification : GeneratedMessage {
    public typealias BuilderType = P2PReceiveConnectNotification.Builder

    public static func == (lhs: P2PReceiveConnectNotification, rhs: P2PReceiveConnectNotification) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSponsorUid == rhs.hasSponsorUid) && (!lhs.hasSponsorUid || lhs.sponsorUid == rhs.sponsorUid)
        fieldCheck = fieldCheck && (lhs.hasSponsorIp == rhs.hasSponsorIp) && (!lhs.hasSponsorIp || lhs.sponsorIp == rhs.sponsorIp)
        fieldCheck = fieldCheck && (lhs.hasSponsorPort == rhs.hasSponsorPort) && (!lhs.hasSponsorPort || lhs.sponsorPort == rhs.sponsorPort)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    /// 发起者uid
    public fileprivate(set) var sponsorUid:UInt32! = nil
    public fileprivate(set) var hasSponsorUid:Bool = false

    /// 发起者的ip
    public fileprivate(set) var sponsorIp:String! = nil
    public fileprivate(set) var hasSponsorIp:Bool = false

    /// 发起者的端口
    public fileprivate(set) var sponsorPort:Int32! = nil
    public fileprivate(set) var hasSponsorPort:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSponsorUid {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:sponsorUid)
        }
        if hasSponsorIp {
            try codedOutputStream.writeString(fieldNumber: 2, value:sponsorIp)
        }
        if hasSponsorPort {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:sponsorPort)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSponsorUid {
            serialize_size += sponsorUid.computeUInt32Size(fieldNumber: 1)
        }
        if hasSponsorIp {
            serialize_size += sponsorIp.computeStringSize(fieldNumber: 2)
        }
        if hasSponsorPort {
            serialize_size += sponsorPort.computeInt32Size(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PReceiveConnectNotification.Builder {
        return P2PReceiveConnectNotification.classBuilder() as! P2PReceiveConnectNotification.Builder
    }
    public func getBuilder() -> P2PReceiveConnectNotification.Builder {
        return classBuilder() as! P2PReceiveConnectNotification.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PReceiveConnectNotification.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PReceiveConnectNotification.Builder()
    }
    public func toBuilder() throws -> P2PReceiveConnectNotification.Builder {
        return try P2PReceiveConnectNotification.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PReceiveConnectNotification) throws -> P2PReceiveConnectNotification.Builder {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSponsorUid {
            jsonMap["sponsorUid"] = UInt(sponsorUid)
        }
        if hasSponsorIp {
            jsonMap["sponsorIp"] = sponsorIp
        }
        if hasSponsorPort {
            jsonMap["sponsorPort"] = Int(sponsorPort)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSponsorUid {
            output += "\(indent) sponsorUid: \(sponsorUid) \n"
        }
        if hasSponsorIp {
            output += "\(indent) sponsorIp: \(sponsorIp) \n"
        }
        if hasSponsorPort {
            output += "\(indent) sponsorPort: \(sponsorPort) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSponsorUid {
                hashCode = (hashCode &* 31) &+ sponsorUid.hashValue
            }
            if hasSponsorIp {
                hashCode = (hashCode &* 31) &+ sponsorIp.hashValue
            }
            if hasSponsorPort {
                hashCode = (hashCode &* 31) &+ sponsorPort.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PReceiveConnectNotification"
    }
    override public func className() -> String {
        return "P2PReceiveConnectNotification"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PReceiveConnectNotification = P2PReceiveConnectNotification()
        public func getMessage() -> P2PReceiveConnectNotification {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        /// 发起者uid
        public var sponsorUid:UInt32 {
            get {
                return builderResult.sponsorUid
            }
            set (value) {
                builderResult.hasSponsorUid = true
                builderResult.sponsorUid = value
            }
        }
        public var hasSponsorUid:Bool {
            get {
                return builderResult.hasSponsorUid
            }
        }
        @discardableResult
        public func setSponsorUid(_ value:UInt32) -> P2PReceiveConnectNotification.Builder {
            self.sponsorUid = value
            return self
        }
        @discardableResult
        public func clearSponsorUid() -> P2PReceiveConnectNotification.Builder{
            builderResult.hasSponsorUid = false
            builderResult.sponsorUid = nil
            return self
        }
        /// 发起者的ip
        public var sponsorIp:String {
            get {
                return builderResult.sponsorIp
            }
            set (value) {
                builderResult.hasSponsorIp = true
                builderResult.sponsorIp = value
            }
        }
        public var hasSponsorIp:Bool {
            get {
                return builderResult.hasSponsorIp
            }
        }
        @discardableResult
        public func setSponsorIp(_ value:String) -> P2PReceiveConnectNotification.Builder {
            self.sponsorIp = value
            return self
        }
        @discardableResult
        public func clearSponsorIp() -> P2PReceiveConnectNotification.Builder{
            builderResult.hasSponsorIp = false
            builderResult.sponsorIp = nil
            return self
        }
        /// 发起者的端口
        public var sponsorPort:Int32 {
            get {
                return builderResult.sponsorPort
            }
            set (value) {
                builderResult.hasSponsorPort = true
                builderResult.sponsorPort = value
            }
        }
        public var hasSponsorPort:Bool {
            get {
                return builderResult.hasSponsorPort
            }
        }
        @discardableResult
        public func setSponsorPort(_ value:Int32) -> P2PReceiveConnectNotification.Builder {
            self.sponsorPort = value
            return self
        }
        @discardableResult
        public func clearSponsorPort() -> P2PReceiveConnectNotification.Builder{
            builderResult.hasSponsorPort = false
            builderResult.sponsorPort = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PReceiveConnectNotification.Builder {
            builderResult = P2PReceiveConnectNotification()
            return self
        }
        override public func clone() throws -> P2PReceiveConnectNotification.Builder {
            return try P2PReceiveConnectNotification.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PReceiveConnectNotification {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PReceiveConnectNotification {
            let returnMe:P2PReceiveConnectNotification = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PReceiveConnectNotification) throws -> P2PReceiveConnectNotification.Builder {
            if other == P2PReceiveConnectNotification() {
                return self
            }
            if other.hasSponsorUid {
                sponsorUid = other.sponsorUid
            }
            if other.hasSponsorIp {
                sponsorIp = other.sponsorIp
            }
            if other.hasSponsorPort {
                sponsorPort = other.sponsorPort
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PReceiveConnectNotification.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PReceiveConnectNotification.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    sponsorUid = try codedInputStream.readUInt32()

                case 18:
                    sponsorIp = try codedInputStream.readString()

                case 24:
                    sponsorPort = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PReceiveConnectNotification.Builder {
            let resultDecodedBuilder = P2PReceiveConnectNotification.Builder()
            if let jsonValueSponsorUid = jsonMap["sponsorUid"] as? UInt {
                resultDecodedBuilder.sponsorUid = UInt32(jsonValueSponsorUid)
            } else if let jsonValueSponsorUid = jsonMap["sponsorUid"] as? String {
                resultDecodedBuilder.sponsorUid = UInt32(jsonValueSponsorUid)!
            }
            if let jsonValueSponsorIp = jsonMap["sponsorIp"] as? String {
                resultDecodedBuilder.sponsorIp = jsonValueSponsorIp
            }
            if let jsonValueSponsorPort = jsonMap["sponsorPort"] as? Int {
                resultDecodedBuilder.sponsorPort = Int32(jsonValueSponsorPort)
            } else if let jsonValueSponsorPort = jsonMap["sponsorPort"] as? String {
                resultDecodedBuilder.sponsorPort = Int32(jsonValueSponsorPort)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PReceiveConnectNotification.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PReceiveConnectNotification.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

/// 对方准备就绪的时候 发起方收到该通知
final public class P2PConnectReadyNotification : GeneratedMessage {
    public typealias BuilderType = P2PConnectReadyNotification.Builder

    public static func == (lhs: P2PConnectReadyNotification, rhs: P2PConnectReadyNotification) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUid == rhs.hasUid) && (!lhs.hasUid || lhs.uid == rhs.uid)
        fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
        fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var uid:UInt32! = nil
    public fileprivate(set) var hasUid:Bool = false

    public fileprivate(set) var ip:String! = nil
    public fileprivate(set) var hasIp:Bool = false

    public fileprivate(set) var port:Int32! = nil
    public fileprivate(set) var hasPort:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUid {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:uid)
        }
        if hasIp {
            try codedOutputStream.writeString(fieldNumber: 2, value:ip)
        }
        if hasPort {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:port)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUid {
            serialize_size += uid.computeUInt32Size(fieldNumber: 1)
        }
        if hasIp {
            serialize_size += ip.computeStringSize(fieldNumber: 2)
        }
        if hasPort {
            serialize_size += port.computeInt32Size(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> P2PConnectReadyNotification.Builder {
        return P2PConnectReadyNotification.classBuilder() as! P2PConnectReadyNotification.Builder
    }
    public func getBuilder() -> P2PConnectReadyNotification.Builder {
        return classBuilder() as! P2PConnectReadyNotification.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PConnectReadyNotification.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return P2PConnectReadyNotification.Builder()
    }
    public func toBuilder() throws -> P2PConnectReadyNotification.Builder {
        return try P2PConnectReadyNotification.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:P2PConnectReadyNotification) throws -> P2PConnectReadyNotification.Builder {
        return try P2PConnectReadyNotification.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUid {
            jsonMap["uid"] = UInt(uid)
        }
        if hasIp {
            jsonMap["ip"] = ip
        }
        if hasPort {
            jsonMap["port"] = Int(port)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUid {
            output += "\(indent) uid: \(uid) \n"
        }
        if hasIp {
            output += "\(indent) ip: \(ip) \n"
        }
        if hasPort {
            output += "\(indent) port: \(port) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUid {
                hashCode = (hashCode &* 31) &+ uid.hashValue
            }
            if hasIp {
                hashCode = (hashCode &* 31) &+ ip.hashValue
            }
            if hasPort {
                hashCode = (hashCode &* 31) &+ port.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "P2PConnectReadyNotification"
    }
    override public func className() -> String {
        return "P2PConnectReadyNotification"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:P2PConnectReadyNotification = P2PConnectReadyNotification()
        public func getMessage() -> P2PConnectReadyNotification {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var uid:UInt32 {
            get {
                return builderResult.uid
            }
            set (value) {
                builderResult.hasUid = true
                builderResult.uid = value
            }
        }
        public var hasUid:Bool {
            get {
                return builderResult.hasUid
            }
        }
        @discardableResult
        public func setUid(_ value:UInt32) -> P2PConnectReadyNotification.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> P2PConnectReadyNotification.Builder{
            builderResult.hasUid = false
            builderResult.uid = nil
            return self
        }
        public var ip:String {
            get {
                return builderResult.ip
            }
            set (value) {
                builderResult.hasIp = true
                builderResult.ip = value
            }
        }
        public var hasIp:Bool {
            get {
                return builderResult.hasIp
            }
        }
        @discardableResult
        public func setIp(_ value:String) -> P2PConnectReadyNotification.Builder {
            self.ip = value
            return self
        }
        @discardableResult
        public func clearIp() -> P2PConnectReadyNotification.Builder{
            builderResult.hasIp = false
            builderResult.ip = nil
            return self
        }
        public var port:Int32 {
            get {
                return builderResult.port
            }
            set (value) {
                builderResult.hasPort = true
                builderResult.port = value
            }
        }
        public var hasPort:Bool {
            get {
                return builderResult.hasPort
            }
        }
        @discardableResult
        public func setPort(_ value:Int32) -> P2PConnectReadyNotification.Builder {
            self.port = value
            return self
        }
        @discardableResult
        public func clearPort() -> P2PConnectReadyNotification.Builder{
            builderResult.hasPort = false
            builderResult.port = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> P2PConnectReadyNotification.Builder {
            builderResult = P2PConnectReadyNotification()
            return self
        }
        override public func clone() throws -> P2PConnectReadyNotification.Builder {
            return try P2PConnectReadyNotification.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> P2PConnectReadyNotification {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> P2PConnectReadyNotification {
            let returnMe:P2PConnectReadyNotification = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:P2PConnectReadyNotification) throws -> P2PConnectReadyNotification.Builder {
            if other == P2PConnectReadyNotification() {
                return self
            }
            if other.hasUid {
                uid = other.uid
            }
            if other.hasIp {
                ip = other.ip
            }
            if other.hasPort {
                port = other.port
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> P2PConnectReadyNotification.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnectReadyNotification.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    uid = try codedInputStream.readUInt32()

                case 18:
                    ip = try codedInputStream.readString()

                case 24:
                    port = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> P2PConnectReadyNotification.Builder {
            let resultDecodedBuilder = P2PConnectReadyNotification.Builder()
            if let jsonValueUid = jsonMap["uid"] as? UInt {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)
            } else if let jsonValueUid = jsonMap["uid"] as? String {
                resultDecodedBuilder.uid = UInt32(jsonValueUid)!
            }
            if let jsonValueIp = jsonMap["ip"] as? String {
                resultDecodedBuilder.ip = jsonValueIp
            }
            if let jsonValuePort = jsonMap["port"] as? Int {
                resultDecodedBuilder.port = Int32(jsonValuePort)
            } else if let jsonValuePort = jsonMap["port"] as? String {
                resultDecodedBuilder.port = Int32(jsonValuePort)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> P2PConnectReadyNotification.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try P2PConnectReadyNotification.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension NotificationMsg: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<NotificationMsg> {
        var mergedArray = Array<NotificationMsg>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> NotificationMsg? {
        return try NotificationMsg.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(data: data, extensionRegistry:NotificationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationMsg {
        return try NotificationMsg.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "targetUid": return self.targetUid
        case "body": return self.body
        default: return nil
        }
    }
}
extension NotificationMsg.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = NotificationMsg
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "targetUid": return self.targetUid
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? EnumNotificationType else {
                    return
                }
                self.type = newSubscriptValue
            case "targetUid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.targetUid = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PReceiveConnectNotification: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PReceiveConnectNotification> {
        var mergedArray = Array<P2PReceiveConnectNotification>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PReceiveConnectNotification? {
        return try P2PReceiveConnectNotification.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(data: data, extensionRegistry:NotificationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PReceiveConnectNotification {
        return try P2PReceiveConnectNotification.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sponsorUid": return self.sponsorUid
        case "sponsorIp": return self.sponsorIp
        case "sponsorPort": return self.sponsorPort
        default: return nil
        }
    }
}
extension P2PReceiveConnectNotification.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PReceiveConnectNotification
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sponsorUid": return self.sponsorUid
            case "sponsorIp": return self.sponsorIp
            case "sponsorPort": return self.sponsorPort
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sponsorUid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sponsorUid = newSubscriptValue
            case "sponsorIp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sponsorIp = newSubscriptValue
            case "sponsorPort":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.sponsorPort = newSubscriptValue
            default: return
            }
        }
    }
}
extension P2PConnectReadyNotification: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<P2PConnectReadyNotification> {
        var mergedArray = Array<P2PConnectReadyNotification>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> P2PConnectReadyNotification? {
        return try P2PConnectReadyNotification.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(data: data, extensionRegistry:NotificationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> P2PConnectReadyNotification {
        return try P2PConnectReadyNotification.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uid": return self.uid
        case "ip": return self.ip
        case "port": return self.port
        default: return nil
        }
    }
}
extension P2PConnectReadyNotification.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = P2PConnectReadyNotification
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uid": return self.uid
            case "ip": return self.ip
            case "port": return self.port
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.uid = newSubscriptValue
            case "ip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.port = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
